<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Automata</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Automata.AutomataException">
            <summary>
            Exeption thrown by the automata constructions
            </summary>
        </member>
        <member name="F:Microsoft.Automata.AutomataException.kind">
            <summary>
            the kind of exception
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataException.#ctor(System.String,System.Exception)">
            <summary>
            construct an exception
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataException.#ctor(System.String)">
            <summary>
            construct an exception with given message
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataException.#ctor(Microsoft.Automata.AutomataExceptionKind)">
            <summary>
            construct an exception with given kind
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataException.#ctor(Microsoft.Automata.AutomataExceptionKind,System.Exception)">
            <summary>
            construct an exception with given kind and inner exception
            </summary>
        </member>
        <member name="T:Microsoft.Automata.AutomataExceptionKind">
            <summary>
            Kinds of exceptions that may be thrown by the Automata library operations.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Automaton`1">
            <summary>
            Symbolic Finite Automaton, provides basic generic algorithms for manipulating SFAs
            </summary>
            <typeparam name="T">type of the labels</typeparam>
        </member>
        <member name="P:Microsoft.Automata.Automaton`1.Algebra">
            <summary>
            Solver for labels
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Automaton`1.FinalState">
            <summary>
            Gets some final state of the automaton
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Automaton`1.IsLoopFree">
            <summary>
            Returns true iff the automaton has no states p such that there is a nonempty path from p to p.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.CheckIfSequence(System.Int32@)">
            <summary>
            Returns true iff the automaton isnonempty has a single initial state and a single final state, and
            either the initial state is also final and has no transitions or a loop, 
            the initial state has no incoming transtions, the final state has either no outgoing transitions or has a single selfloop, 
            and all other states have one incoming and one outgoing transition.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.TopSort">
            <summary>
            Returns a topological sorting of all the states. 
            Returns null iff the graph is cyclic.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MkEpsilon(Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            The automaton that accepts only the empty word.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MkFull(Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            The automaton that accepts nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetEpsilonClosure(System.Int32)">
            <summary>
            Returns all states that are reachable via epsilon moves, including the state itself.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetInvEpsilonClosure(System.Int32)">
            <summary>
            Returns all states that are reachable via backwards epsilon moves, including the state itself.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Automaton`1.IsEmpty">
            <summary>
            True iff there are no final states
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Automaton`1.IsEpsilon">
            <summary>
            True iff there are no moves and the initial state is also final.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Create(Microsoft.Automata.IBooleanAlgebra{`0},System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Microsoft.Automata.Move{`0}},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create a symbolic automaton.
            </summary>
            <param name="initialState">initial state</param>
            <param name="finalStates">final states</param>
            <param name="moves">moves</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.#ctor(Microsoft.Automata.Automaton{`0})">
            <summary>
            Creates a shallow copy of aut with exactly the same fields
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.RelpaceAllGuards(System.Func{`0,`0})">
            <summary>
            Convert the automaton to an automaton where each guard p has been replaced with transform(p).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.ReplaceAlgebra``1(System.Func{`0,``0},Microsoft.Automata.IBooleanAlgebra{``0})">
            <summary>
            Convert the T-automaton to an S-automaton where each guard p has been replaced with f(p) and the S-algebra is alg.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.ProjectSecond``1(Microsoft.Automata.Automaton{Microsoft.Automata.BooleanAlgebras.IMonadicPredicate{``0,`0}})">
            <summary>
            Project the second component an automaton with monadic predicates.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Automaton`1.MaxState">
            <summary>
            A number that is either equal to or greater than the largest state id used in the SFA
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Concat(Microsoft.Automata.Automaton{`0})">
            <summary>
            Assumes that the states of the SFAs are disjoint and adds epsilon transitions if needed.
            Assumes also that fa is not Empty and not Epsilon.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MakeInitialStateFinal">
            <summary>
            Mark the initial state as a final state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.AddMove(Microsoft.Automata.Move{`0})">
            <summary>
            Add a new move.
            </summary>
            <param name="move">move to be added</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.IsKleeneClosure">
            <summary>
            Returns true if there is an epsilon move from each final state to the initial state 
            and the initial state is also final
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.AddNewInitialStateThatIsFinal(System.Int32)">
            <summary>
            Adds a new initial state that is also marked as a final state.
            Adds an epsilon transition from the new initial state to the original initial state.
            Assumes that newInitialState does not occur in the set of states.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.RemoveTheState(System.Int32)">
            <summary>
            Remove the state.
            </summary>
            <param name="state">state to be removed, must not be the initial state</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetCondition(System.Int32,System.Int32)">
            <summary>
            Get the condition from the move from source to target
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MkProduct(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            Make a product of a and b. First removes epsilons from a and b.
            </summary>
            <param name="a">first automaton</param>
            <param name="b">second automaton</param>
            <param name="timeout">timeout in milliseconds</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MkProduct_(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0},Microsoft.Automata.IBooleanAlgebraPositive{`0})">
            <summary>
            Internal usage when a and b have algebra = null, algebra is passed in explicitly
            and is only required to be IBooleanAlgebraPositive.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MkSum(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            Make a sum (union) of a and b. Produces an automaton a+b such that L(a+b) = L(a) union L(b)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MkSum(Microsoft.Automata.Automaton{`0},System.Collections.Generic.IEnumerable{Microsoft.Automata.Automaton{`0}})">
            <summary>
            Make a sum (union) of a and b. Produces an automaton a+b such that L(a+b) = L(a) union L(b)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.RemoveEpsilonLoops">
            <summary>
            Remove epsilon loops from this fsa and normalize the result, use disj to 
            to make disjunctions of conditions during normalization
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.RemoveEpsilons">
            <summary> 
            Creates an automaton without epsilon transitions.
            States unreachable from the initial state are eliminated.
            The reachable states remain the same.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.RemoveEpsilons(System.Func{`0,`0,`0})">
            <summary> 
            Used internally or when algebra=null
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.EliminateDeadStates">
            <summary>
            Eliminate all non-initial states from the automaton from which no final state is recahable 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.EliminateUnrreachableStates">
            <summary>
            Eliminate all non-initial states from the automaton from which no final state is recahable 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Minus(Microsoft.Automata.Automaton{`0})">
            <summary>
            Creates the automaton that accepts L(this)-L(B).
            </summary>
            <param name="B">another automaton</param>
            <param name="solver">boolean algebra solver over S</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Complement">
            <summary>
            Creates the automaton that accepts the complement of L(this).
            </summary>
            <param name="solver">boolean algebra solver over S</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Intersect(Microsoft.Automata.Automaton{`0},System.Int32)">
            <summary>
            Creates the automaton that accepts the intersection of L(this) and L(B).
            </summary>
            <param name="B">another automaton</param>
            <param name="solver">boolean algebra solver over S</param>
            <param name="timeout">timeout in ms</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Union(Microsoft.Automata.Automaton{`0})">
            <summary>
            Creates the automaton that accepts the union of L(this) and L(B).
            Uses additional epsilon transitions and does not need the solver for S.
            </summary>
            <param name="B">another automaton</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Union(System.Collections.Generic.IEnumerable{Microsoft.Automata.Automaton{`0}})">
            <summary>
            Creates the automaton that accepts the union of L(this) and L(B).
            Uses additional epsilon transitions and does not need the solver for S.
            </summary>
            <param name="B">another automaton</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.SuffixLanguage">
            <summary>
            Returns the language containing all the suffixes of L
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.PrefixLanguage">
            <summary>
            Returns the language containing all the prefixes of L
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.IsEquivalentWith(Microsoft.Automata.Automaton{`0},System.Collections.Generic.List{`0}@)">
            <summary>
            Returns true iff this automaton and another automaton B are equivalent
            </summary>
            <param name="B">another automaton</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.IsEquivalentWith(Microsoft.Automata.Automaton{`0})">
            <summary>
            Returns true iff this automaton and another automaton B are equivalent
            </summary>
            <param name="B">another automaton</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.areHKEquivalent(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            Checks whether laut and raut are equivalent using HopcroftKarp on the SFA
            accepting the reverse language
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.areHKEquivalentDeterministic(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            Checks whether laut and raut are equivalent using HopcroftKarp on the SFA
            accepting the reverse language
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MkDifference(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0},System.Int32)">
            <summary>
            Make the automaton A x Complement(B). The automaton is empty iff L(A) is a subset of L(B).
            Throws TimeoutException if the construction does not finish within the given mumber of milliseconds.
            </summary>
            <param name="A">subset automaton</param>
            <param name="B">superset automaton</param>
            <param name="timeout">timeout in milliseconds (0 or a negative number means no timeout)</param>
            <returns>automaton accepting L(A x Complement(B))</returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.CheckDifference(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0},System.Int32,System.Collections.Generic.List{`0}@)">
            <summary>
            Returns true iff A-B is nonempty.
            If true, outputs a witness that is a symbolic trace in A but not in B.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MakeTotal">
            <summary>
            The sink state will be the state with the largest id.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MkComplement(Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Make a complement of the automaton.
            The automaton must be deterministic, otherwise throws AutomataException.
            </summary>
            <param name="solver">solver for character constraints</param>
            <returns>Complement of this automaton</returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.CheckDeterminism(System.Boolean)">
            <summary>
            Checks that for all states q, if q has two or more outgoing 
            moves then the conditions of the moves are pairwise disjoint, i.e., 
            their conjunction is unsatisfiable. 
            If the check succeeds, sets IsDeterministic to true.
            Throws AutomataException if the FSA is not epsilon-free.
            </summary>
            <param name="solver">used to make conjunctions and to check satisfiability of resulting conditions</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.IsAmbiguous(Microsoft.Automata.Automaton{`0}@)">
            <summary>
            Checks whether the autoamton is ambiguous, and returns the ambiguous set of string in the output
            paramter <i>ambiguousLanguage</i>
            </summary>
            <param name="solver">used to make conjunctions and to check satisfiability of resulting conditions</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.CheckProduct(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0},System.Int32,System.Collections.Generic.List{`0}@)">
            <summary>
            Returns true if the intersection of L(A) and L(B) is nonempty i.e. if L(A*B) is nonempty. 
            Produces a symbolic list of elements that represents a path in A*B if the intersection is nonempty.
            </summary>
            <param name="A">FSA to be intersected</param>
            <param name="B">FSA to be intersected</param>
            <param name="witness">symbolic list of elements that represents a path from the initial state to a final state in A*B</param>
            <param name="timeout">timeout in milliseconds for termination, 0 or negative number means no timeout</param>
            <returns>true iff the intersection of L(A) and L(B) is nonempty</returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Determinize(Microsoft.Automata.PowerSetStateBuilder@,System.Int32)">
            <summary>
            Determinize and return the state builder that maps generated states to sets of original states
            </summary>
            <param name="timeout">if 0 then no timeout is enforced else it is the nr of ms</param>
            <param name="statebuilder">maps generated state ids to sets of original state ids</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MinimizeMoore(System.Int32)">
            <summary>
            Minimization of SFAs using a symbolic generalization of Moore's algorithm.
            This algorithm is quadratic in the number of states.
            If the SFA is nondeterministic, the minimized SFA will be equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MinimizeHopcroft(System.Int32)">
            <summary>
            Minimization of FAs using a symbolic generalization of Hopcroft's algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.NonDetGetMinAut(System.Int32)">
            <summary>
            Minimization of SFAs.
            Can also be applied to nondeterministic SFAs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Minimize">
            <summary>
            Minimization of SFAs.
            Can also be applied to nondeterministic SFAs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MinSFANew(Microsoft.Automata.Automaton{`0})">
            <summary>
            Algorithm MinSFA from POPL14.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MinSFACount(Microsoft.Automata.Automaton{`0})">
            <summary>
            NFA minimization algorithm based on counting
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MinSFA(Microsoft.Automata.Automaton{`0})">
            <summary>
            Algorithm MinSFA from POPL14.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MinBiSim(Microsoft.Automata.Automaton{`0})">
            <summary>
            Algorithm for minimizing nondeterministic SFAs based on bisimilarity of states.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.SimBlockContainer.RemoveBlock">
            <summary>
            Container is assumed two contain at least two blocks.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.MinimizeClassical(System.Int32,System.Boolean)">
            <summary>
            Extension of standard minimization of FAs, use timeout.
            This is a naive cubic algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Reverse">
            <summary>
            Creates an automaton that accepts the reverse of the language.
            The resulting automaton will contain epsilon moves if this automaton has more than one final state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.ChoosePathToSomeFinalState(Microsoft.Automata.Chooser)">
            <summary>
            Produces a random path of labels from the initial state to some final state.
            Assumes that the automaton is nonempty and does not contain deadends.
            </summary>
            <param name="chooser">uses the chooser for randomizing the choices</param>
        </member>
        <member name="P:Microsoft.Automata.Automaton`1.InitialState">
            <summary>
            The initial state of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.IsFinalState(System.Int32)">
            <summary>
            Returns true iff the state is a final state of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.IsLoopState(System.Int32)">
            <summary>
            Returns true iff there exists a move from state to state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetStates">
            <summary>
            Enumerates all states of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetTargetState_(System.Int32,`0)">
            <summary>
            Assumes that the automaton has some target state for 
            some element in the given predicate and returns such a target state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.TryGetTargetState_(System.Int32,System.Int32@,`0)">
            <summary>
            Returns true if the automaton has some target state for 
            some element in the given predicate then such a target state is output. 
            Else returns false and sets target to -1.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetTargetState(System.Int32,`0[])">
            <summary>
            Assumes that the automaton is total and deterministic and all input predicates are satisfiable. 
            Returns the target state after the given sequence of inputs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.TryGetTargetState(System.Int32,System.Int32@,`0[])">
            <summary>
            Returns true if the automaton has some target state for 
            some elements in the given predicate sequence, then such a target is output. 
            Else returns false and sets target to -1.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetMoves">
            <summary>
            Enumerates all moves of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.DescribeState(System.Int32)">
            <summary>
            Returns state.ToString().
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.DescribeLabel(`0)">
            <summary>
            Returns lab.ToString(), or the empty string when S is not a value type and lab is null. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetProbability(Microsoft.Automata.Move{`0})">
            <summary>
            Gets the probability of moving with the given move.
            </summary>
            <param name="move">given move of the automaton</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.GetProbability(System.Int32)">
            <summary>
            Gets the probability of finalizing in state q. 
            Returns 0.0 if q is not a final state.
            </summary>
            <param name="q">given state of the automaton</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.ComputeProbabilities(System.Func{`0,System.UInt64})">
            <summary>
            Associates all moves and final states with a probability that is a double between 0.0 and 1.0.
            The sum of probabilities of all outgoing moves from a state plus the probability of finishing in the state is 1.0.
            The probability of a move (s,l,t) is (f(l) * DomainSize(t)) / DomainSize(s). 
            where DomainSize(s) is the sum of all f(l) * DomainSize(t) such that (s,l,t) 
            is a move from s, plus 1 if s is a final state.
            The method requires that the automaton has no loops, no deadends and is deterministic.
            </summary>
            <param name="f">function that calculates the cardinality of a label of a move</param>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.ChooseTransitionUniformly(Microsoft.Automata.Chooser,System.Int32)">
            <summary>
            Returns null if st is a final state and the final implicit 
            epsilon transition was chosen to the imaginary final sink state
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.FindShortestFinalPath(System.Int32)">
            <summary>
            Returns a path from pStart to a final state.
            If there are no epsilon moves then the path is shortest.
            Returns null if pStart does not lead to a final state.
            </summary>
            <param name="pStart">given start state</param>
            <returns>(label path, final state) or null</returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Normalize(System.Int32)">
             <summary>
            States are counted consequtively from q0 to q0+n is there are n states (the automaton is made total).
            If the original automaton was partial then q0+n is a nonaccepting sink state.
            Automaton is assumed to be epsilon free.
             </summary>
             <param name="q0">the id of the initial state default is 0</param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Automaton`1.Compile(System.String,System.String)">
            <summary>
            Normalizes and compiles the automaton to 
            C# code that is exposed through the ICompiledStringMatcher interface.
            The automaton must be deterministic and the algebra must be CharSetSolver.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.AutomatonSerializer`1">
            <summary>
            Is used as a base class of automata classes that implement the IAutomaton interface
            and the INameProvider interface.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomatonSerializer`1.ShowGraph">
            <summary>
            Saves the automaton in <paramref name="Name"/>.dgml file in the working directory
            and opens the file in a new process.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomatonSerializer`1.SaveAsDgml">
            <summary>
            Saves the automaton in dgml format in <paramref name="Name"/>.dgml file in the working directory.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomatonSerializer`1.SaveAsDot">
            <summary>
            Saves the automaton in dot format in <paramref name="Name"/>.dot file in the working directory.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomatonSerializer`1.SaveAsDot(System.String)">
            <summary>
            Saves the automaton in dot format in the given file in the working directory.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomatonSerializer`1.SaveAsDgml(System.IO.TextWriter)">
            <summary>
            Saves the automaton in dgml format in tw.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomatonSerializer`1.SaveAsDot(System.IO.TextWriter)">
            <summary>
            Saves the automaton in dot format in tw.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BasicCountingSet">
            <summary>
            Implements a bounded set on integers that supports incermenting all elements adding 0 and 1.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BasicCountingSet.upperBound">
            <summary>
            Upper limit on what the maximum value in the set can be.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BasicCountingSet.UpperBound">
            <summary>
            Upper limit on what the maximum value in the set can be.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BasicCountingSet.IsEmpty">
            <summary>
            True iff the counting set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BasicCountingSet.IsSingleton">
            <summary>
            True iff the counting set is a singleton set.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BasicCountingSet.IsFull">
            <summary>
            True iff the counting set is full.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BasicCountingSet.CountElements">
            <summary>
            Size of counting set
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.#ctor(Microsoft.Automata.ICounter)">
            <summary>
            Create a counting set, max is the maximum element size, max must be at least 2 and initialize it to 0.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BasicCountingSet.Max">
            <summary>
            Gets the maximum value in the set. Set must be nonempty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BasicCountingSet.Min">
            <summary>
            Gets the minimum value in the set. Set must be nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.Set0">
            <summary>
            Set the counting set to the value [0].
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.Set1">
            <summary>
            Set the counting set to the value [1].
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.Incr">
            <summary>
            Increment all values in the set.
            If Max becomes greater than UpperBound then remove it.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.Push0">
            <summary>
            Push 0 into the set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.Push1">
            <summary>
            Push 1 into the set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.Clear(Microsoft.Automata.ICounter)">
            <summary>
            Empty the set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.IncrPush0">
            <summary>
            Increment all values in the set and push 0 into the set.
            If Max becomes greater than UpperBound then remove it.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.IncrPush1">
            <summary>
            Increment all values in the set and push 1 into the set.
            If Max becomes greater than UpperBound then remove it.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.IncrPush01">
            <summary>
            Increment all values in the set and push 0 and 1 into the set.
            If Max becomes greater than UpperBound then remove it.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BasicCountingSet.ToString">
            <summary>
            Returns decimal representation of the elements in the set in decreasing order.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BDD">
            <summary>
            Represents a Binary Decision Diagram.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDD.One">
            <summary>
            The encoding of the set for lower ordinals for the case when the current bit is 1.
            The value is null iff IsLeaf is true.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDD.Zero">
            <summary>
            The encoding of the set for lower ordinals for the case when the current bit is 0.
            The value is null iff IsLeaf is true.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDD.Ordinal">
            <summary>
            Ordinal of this bit if nonleaf
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BDD.IsLeaf">
            <summary>
            True iff the node is a terminal (One and Zero are null).
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BDD.IsFull">
            <summary>
            True iff the set is full.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BDD.IsEmpty">
            <summary>
            True iff the set is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDD.CountNodes">
            <summary>
            Counts the number of nodes (both terminals and nonterminals) in the BDD.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDD.ToDot(System.String)">
            <summary>
            Store the BDD as a graph in the given file.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDD.GetMin">
            <summary>
            Gets the lexicographically minimum bitvector in this BDD as a ulong.
            Assumes that this BDD is nonempty and that its ordinal is at most 63.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDD.ShiftRight(System.Int32)">
            <summary>
            Decrement the ordinals of all nodes by k, k must be nonnegative.
            </summary>
            <param name="k">offset</param>
        </member>
        <member name="M:Microsoft.Automata.BDD.ShiftLeft(System.Int32)">
            <summary>
            Increment the ordinals of all nodes by k, k must be nonnegative.
            </summary>
            <param name="k">offset</param>
        </member>
        <member name="M:Microsoft.Automata.BDD.CompareTo(System.Object)">
            <summary>
            returns -1 if the minimum element in this BDD is smaller than the minimum element in the otther BDD or if this BDD is empty
            returns 0 if the minimum elements are equal or if the BDDs are equal, 
            returns 1 otherwise
            </summary>
            <param name="other">the other BDD</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.IBDDAlgebra">
            <summary>
            Bitwise operations over BDDs.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BDDAlgebra">
            <summary>
            Solver for BDDs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.#ctor">
            <summary>
            Construct a solver for bitvector sets.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkOr(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Make the union of a and b
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkAnd(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Make the intersection of a and b
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkDiff(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Make the difference a - b
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkNot(Microsoft.Automata.BDD)">
            <summary>
            Complement a
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkAnd(System.Collections.Generic.IEnumerable{Microsoft.Automata.BDD})">
            <summary>
            Intersect all sets in the enumeration
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkOr(System.Collections.Generic.IEnumerable{Microsoft.Automata.BDD})">
            <summary>
            Take the union of all sets in the enumeration
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BDDAlgebra.True">
            <summary>
            Gets the full set.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BDDAlgebra.False">
            <summary>
            Gets the empty set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.IsSatisfiable(Microsoft.Automata.BDD)">
            <summary>
            Returns true if the set is nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.AreEquivalent(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Returns true if a and b represent mathematically equal sets of characters.
            Two BDDs are by construction equivalent iff they are identical.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.ShiftRight(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Shift all elements k (=1 by default) bits to the right. 
            For example if set denotes {*0000,*1110,*1111} then 
            ShiftRight(set) denotes {*000,*111} where * denotes any prefix of 0's or 1's.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.ShiftRight0(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            First applies ShiftRight and then sets bit k to 0.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.ShiftLeft(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Shift all elements k bits to the left. 
            For example if k=1 and set denotes {*0000,*1111} then 
            ShiftLeft(set) denotes {*00000,*00001,*11110,*11111} where * denotes any prefix of 0's or 1's.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkBitTrue(System.Int32)">
            <summary>
            Creates the set that contains all elements whose k'th bit is true.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkBitFalse(System.Int32)">
            <summary>
            Creates the set that contains all elements whose k'th bit is false.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkSetFrom(System.UInt32,System.Int32)">
            <summary>
            Make a set containing all integers whose bits up to maxBit equal n.
            </summary>
            <param name="n">the given integer</param>
            <param name="maxBit">bits above maxBit are unspecified</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkSetFrom(System.UInt64,System.Int32)">
            <summary>
            Make a set containing all integers whose bits up to maxBit equal n.
            </summary>
            <param name="n">the given integer</param>
            <param name="maxBit">bits above maxBit are unspecified</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkSetFromRange(System.UInt32,System.UInt32,System.Int32)">
            <summary>
            Make the set containing all values greater than or equal to m and less than or equal to n when considering bits between 0 and maxBit.
            </summary>
            <param name="m">lower bound</param>
            <param name="n">upper bound</param>
            <param name="maxBit">bits above maxBit are unspecified</param>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkSetFromRange(System.UInt64,System.UInt64,System.Int32)">
            <summary>
            Make the set containing all values greater than or equal to m and less than or equal to n.
            </summary>
            <param name="m">lower bound</param>
            <param name="n">upper bound</param>
            <param name="maxBit">bits above maxBit are unspecified</param>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.GetRangeCount(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Convert the set into an equivalent array of ranges and return the number of such ranges.
            Bits above maxBit are ignored.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.ToRanges(Microsoft.Automata.BDD,System.Int32,System.Int32)">
            <summary>
            Convert the set into an equivalent array of uint ranges. 
            Bits above maxBit are ignored.
            The ranges are nonoverlapping and ordered. 
            If limit > 0 and there are more ranges than limit then return null.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.ToRanges64(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Convert the set into an equivalent array of ulong ranges. 
            Bits above maxBit are ignored.
            The ranges are nonoverlapping and ordered. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.ChooseUniformly(Microsoft.Automata.Chooser,Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Choose a member of the set uniformly, each member is chosen with equal probability. Assumes that the set is nonempty.
            </summary>
            <param name="chooser">element chooser</param>
            <param name="set">given set</param>
            <param name="maxBit">bits above maxBit are ignored, maxBit must be at least set.Ordinal</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.ChooseUniformly64(Microsoft.Automata.Chooser,Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Choose a member of the set uniformly, each member is chosen with equal probability. Assumes that the set is nonempty.
            </summary>
            <param name="chooser">element chooser</param>
            <param name="set">given set</param>
            <param name="maxBit">bits above maxBit are ignored, maxBit must be at least set.Ordinal</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.Choose(Microsoft.Automata.Chooser,Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Choose a member of the set. Assumes that the set is nonempty.
            </summary>
            <param name="chooser">element chooser</param>
            <param name="set">given set</param>
            <param name="maxBit">bits over maxBit are ignored</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.GetMax(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Get the lexicographically maximum bitvector in the set. Assumes that the set is nonempty.
            </summary>
            <param name="set">the given nonempty set</param>
            <param name="maxBit">bits above maxBit are ignored, b must be at least set.Bit</param>
            <returns>the lexicographically largest bitvector in the set</returns>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.ComputeDomainSize(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Calculate the number of elements in the set. Returns 0 when set is full and maxBit is 63.
            </summary>
            <param name="set">the given set</param>
            <param name="maxBit">bits above maxBit are ignored</param>
            <returns>the cardinality of the set</returns>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.GetMin(Microsoft.Automata.BDD)">
            <summary>
            Get the lexicographically minimum bitvector in the set as a ulong.
            Assumes that the set is nonempty and that the ordinal of the BDD is at most 63.
            </summary>
            <param name="set">the given nonempty set</param>
            <returns>the lexicographically smallest bitvector in the set</returns>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkSet(System.UInt32)">
            <summary>
            Make a BDD for the concrete value i with ordinal 31
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.MkSet(System.UInt64)">
            <summary>
            Make a BDD for the concrete value i with ordinal 63
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.Simplify(Microsoft.Automata.BDD)">
            <summary>
            Since the BvSet is always minimal simplify only returns the set itself
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.OmitBit(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Project away the i'th bit. Assumes that bit is nonnegative.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.OmitBitsAbove(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Project away all bits greater or equalt to i. Assumes that bit is nonnegative.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.Serialize(Microsoft.Automata.BDD)">
            <summary>
            Serialize a BDD in a flat ulong array.
            The BDD may have at most 2^16 bits and 2^24 nodes.
            BDD.False is represented by ulong[]{0}.
            BDD.True is represented by ulong[]{0,0}.
            Element at index 0 is the false node,
            element at index 1 is the true node,
            and entry at index i>1 is node i and has the structure:
            (ordinal &lt;&lt; 48) | (trueNode &lt;&lt; 24) | falseNode.
            The root of the BDD (when different from True and False) is node 2.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra.Deserialize(System.UInt64[])">
            <summary>
            Recreates a BDD from a ulong array that has been created using Serialize.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BDDAlgebra`1">
            <summary>
            Solver for multi-terminal BDDs with leaf ordinals that map to predicates from a Boolean algebra over T
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkOr(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Make the union of a and b
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkAnd(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Make the intersection of a and b
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkDiff(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Make the difference a - b
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkNot(Microsoft.Automata.BDD)">
            <summary>
            Complement a
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkAnd(System.Collections.Generic.IEnumerable{Microsoft.Automata.BDD})">
            <summary>
            Intersect all sets in the enumeration
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkAnd(Microsoft.Automata.BDD[])">
            <summary>
            Intersect all the sets.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkOr(System.Collections.Generic.IEnumerable{Microsoft.Automata.BDD})">
            <summary>
            Take the union of all sets in the enumeration
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.IsSatisfiable(Microsoft.Automata.BDD)">
            <summary>
            Returns true if bdd is nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.AreEquivalent(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Two BDDs are by construction equivalent iff they are identical.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkBitTrue(System.Int32)">
            <summary>
            Creates the bdd that contains all elements whose k'th bit is true.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkBitFalse(System.Int32)">
            <summary>
            Creates the set that contains all elements whose k'th bit is false.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.Simplify(Microsoft.Automata.BDD)">
            <summary>
            Identity function
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.OmitBit(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Project away the i'th bit. Assumes that bit is nonnegative.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkDifference(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Returns p-q.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDAlgebra`1.MkSymmetricDifference(Microsoft.Automata.BDD,Microsoft.Automata.BDD)">
            <summary>
            Returns (p-q)|(q-p).
            </summary>
        </member>
        <member name="T:Microsoft.Automata.PredicateIdMapper`1">
            <summary>
            For a given Boolean algebra maps all predicates to unique representatives.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PredicateIdMapper`1.GetId(`0)">
            <summary>
            For all p: p is equivalent to GetId(p).
            For all p and q: if p is equivalent to q then GetId(p)==GetId(q).
            </summary>
            <param name="p">given predicate</param>
        </member>
        <member name="M:Microsoft.Automata.RangeConverter.ToRanges(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Convert the set into an equivalent array of ranges. 
            The ranges are nonoverlapping and ordered. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RangeConverter64.ToRanges(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Convert the set into an equivalent array of ranges. 
            The ranges are nonoverlapping and ordered. 
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BigInt">
            <summary>
            Nonnegative big integers with restricted functionality.
            Wraps System.Numerics.BigInteger.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BigInt.biginteger">
            <summary>
            Underlying BigInteger 
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BooleanAlgebras.BV128">
            <summary>
            128-bit bitvector
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.Equals(System.Object)">
            <summary></summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.ToString">
            <summary></summary>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.BV128.All1">
            <summary>
            All bits are 1
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.BV128.All0">
            <summary>
            All bits are 0
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Constructs a bitvector with 128 bits
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.op_BitwiseAnd(Microsoft.Automata.BooleanAlgebras.BV128,Microsoft.Automata.BooleanAlgebras.BV128)">
            <summary>
            Bitwise AND
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.op_BitwiseOr(Microsoft.Automata.BooleanAlgebras.BV128,Microsoft.Automata.BooleanAlgebras.BV128)">
            <summary>
            Bitwise OR
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.op_ExclusiveOr(Microsoft.Automata.BooleanAlgebras.BV128,Microsoft.Automata.BooleanAlgebras.BV128)">
            <summary>
            Bitwise XOR
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.op_OnesComplement(Microsoft.Automata.BooleanAlgebras.BV128)">
            <summary>
            Bitwise NOT
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BV128.Random">
            <summary>
            Generates a random bitvector.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BooleanAlgebras.CartesianAlgebra`2">
            <summary>
            Cartesian product algebra of two Boolean algebras.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.CartesianAlgebra`2.MkNode(`1,Microsoft.Automata.BooleanAlgebras.BDG{`0,`1},Microsoft.Automata.BooleanAlgebras.BDG{`0,`1})">
            <summary>
            Assumes that pred is sat and ~pred is sat
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.CartesianAlgebra`2.MkLeaf(`0,System.Boolean)">
            <summary>
            Creates a leaf with LeafCondition pred.
            If simplify=true, checks if pred is unsat (returns False) or valid (returns True).
            Assumes that if simplify=false then pred is neither unsat nor valid.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.CartesianAlgebra`2.MkNode(`0,`1)">
            <summary>
            Creates a phi-node with leaves. 
            Represents the set [[t]]x[[s]].
            Assumes that s is satisfiable.
            If s equals True, then creates MkLeaf(t).
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BooleanAlgebras.BDG`2">
            <summary>
            Binary Decision Graph. 
            Used as a predidate in CartesianAlgebra.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BooleanAlgebras.BDG`2.algebra">
            <summary>
            Underlying Cartesian algebra
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.BDG`2.Algebra">
            <summary>
            Underlying Cartesian algebra
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BooleanAlgebras.BDG`2.BranchCondition">
            <summary>
            Branch condition is a predicate of Algebra.NodeAlgebra (if IsLeaf is false else default(S))
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BooleanAlgebras.BDG`2.LeafCondition">
            <summary>
            Leaf condition is a predicate of Algebra.LeafAlgebra (if IsLeaf is true else default(T))
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BooleanAlgebras.BDG`2.TrueCase">
            <summary>
            The case BranchCondition is true (null if IsLeaf is true)
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BooleanAlgebras.BDG`2.FalseCase">
            <summary>
            The case BranchCondition is false (null if IsLeaf is true)
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BooleanAlgebras.BDG`2.Depth">
            <summary>
            Depth is 0 for a leaf and 1 + max(TrueCase.Depth,FalseCase.Depth) for a node
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.BDG`2.IsLeaf">
            <summary>
            Returns true iff depth is 0
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.BDG`2.IsTrue">
            <summary>
            Returns true if this is Alg.True
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.BDG`2.IsFalse">
            <summary>
            Returns true if this is Alg.False
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.#ctor">
            <summary>
            No public constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.MkAnd(Microsoft.Automata.BooleanAlgebras.BDG{`0,`1})">
            <summary>
            Makes the conjunction of this and that
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.MkAnd(`1,Microsoft.Automata.BooleanAlgebras.BDG{`0,`1})">
            <summary>
            Maintains the node invariant: sat(path &amp; nodePred) and sat(path &amp; ~nodePred)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.MkNot">
            <summary>
            Negates the predicate by negating the leaves
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.RestrictLeaves(`0)">
            <summary>
            Restrict the leaf predicates with psi
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.Restrict(`1,`0)">
            <summary>
            Restrict top down wrt the path condition and strengthen the leaf predicates with psi
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.GetSumOfProducts">
            <summary>
            Compute all pairs (s_1,t_1),...,(s_k,t_k) such that 
            the BDG represents ([[s_1]]x[[t_1]]) U ... U ([[s_k]]x[[t_k]])
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.GetSize">
            <summary>
            Computes (number of nonterminals, number of terminals) in the underlying directed acyclic graph.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.BDG`2.TransformLeaves(System.Func{`0,`0})">
            <summary>
            Apply the transformation f to all leaves.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2">
            <summary>
            Implements a disjoint union of two Boolean algebras.
            A Tuple(s,t) represents intuitively the union {(1,x) : x in s} U {(2,x) : x in t}.
            </summary>
            <typeparam name="S">type of the first Boolean algebra</typeparam>
            <typeparam name="T">type of the second Boolean algebra</typeparam>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.First">
            <summary>
            Gets the first algebra.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.Second">
            <summary>
            Gets the second algebra.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.#ctor(Microsoft.Automata.IBooleanAlgebra{`0},Microsoft.Automata.IBooleanAlgebra{`1})">
            <summary>
            Constructs a pair of Boolean algebras that itself is a Boolean algebra over the disjoint union of the domains.
            </summary>
            <param name="first">first algebra</param>
            <param name="second">second algebra</param>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.True">
            <summary>
            Gets the top element.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.False">
            <summary>
            Gets the bottom element.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.MkOr(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
            <summary>
            Returns the pairwise union (disjunction) of the enumerated pairs.
            </summary>
            <param name="predicates">given enumeration of predicate pairs</param>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.MkAnd(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
            <summary>
            Returns the pairwise intersection (conjunction) of the enumerated pairs.
            </summary>
            <param name="predicates">given enumeration of predicate pairs</param>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.MkNot(System.Tuple{`0,`1})">
            <summary>
            Complement the pair predicate by complementing its components.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.Simplify(System.Tuple{`0,`1})">
            <summary>
            Complement the pair predicate by complementing its components.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.AreEquivalent(System.Tuple{`0,`1},System.Tuple{`0,`1})">
            <summary>
            Returns true iff the first components are equivalent and the second components are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.MkOr(System.Tuple{`0,`1},System.Tuple{`0,`1})">
            <summary>
            Makes a union of the first components and a union of the second components.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.MkAnd(System.Tuple{`0,`1},System.Tuple{`0,`1})">
            <summary>
            Makes an intersection of the first components and an intersection of the second components.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.IsSatisfiable(System.Tuple{`0,`1})">
            <summary>
            Returns true iff the first or the second component of the pair predicate is satisfiable.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanAlgebras.DisjointUnionAlgebra`2.GenerateMinterms(System.Tuple{`0,`1}[])">
            <summary>
            Generate minterms for the constraints.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BooleanAlgebras.TrivialBooleanAlgebra">
            <summary>
            Boolean algebra over an atomic universe.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BV64Algebra">
            <summary>
            Bit vector algebra of up to 64 bits
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV64Algebra.ReplaceMintermsWithVisibleCharacters">
            <summary>
            Create a variant of the algebra where each minterms is replaced with a singleton set starting from '0'
            Used for testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV64Algebra.ConvertFromCharSet(Microsoft.Automata.BDD)">
            <summary>
            Assumes that set is a union of some minterms (or empty).
            If null then 0 is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV64Algebra.PrettyPrint(System.UInt64)">
            <summary>
            Pretty print the bitvector predicate as a character class.
            </summary>
            <param name="bv">given bitvector predicate</param>
        </member>
        <member name="M:Microsoft.Automata.BV64Algebra.ChooseUniformly(System.UInt64)">
            <summary>
            Choose a random member uniformly at random from the ulong set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV64Algebra.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV64Algebra.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV64Algebra.SerializePredicate(System.UInt64)">
            <summary>
            Serialize s as a hexadecimal numeral using lowercase letters
            </summary>
            <param name="s">given predicate</param>
        </member>
        <member name="M:Microsoft.Automata.BV64Algebra.DeserializePredicate(System.String)">
            <summary>
            Deserialize s from a string created by SerializePredicate
            </summary>
            <param name="s">given hexadecimal numeral representation</param>
        </member>
        <member name="T:Microsoft.Automata.BVAlgebra">
            <summary>
            Bit vector algebra
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BVAlgebra.ConvertFromCharSet(Microsoft.Automata.BDD)">
            <summary>
            Assumes that set is a union of some minterms (or empty).
            If null then null is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BVAlgebra.PrettyPrint(Microsoft.Automata.BV)">
            <summary>
            Pretty print the bitvector predicate as a character class.
            </summary>
            <param name="bv">given bitvector predicate</param>
        </member>
        <member name="M:Microsoft.Automata.BVAlgebra.ChooseUniformly(Microsoft.Automata.BV)">
            <summary>
            Choose a random member uniformly at random from the BV set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BVAlgebra.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BVAlgebra.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BVAlgebra.SerializePredicate(Microsoft.Automata.BV)">
            <summary>
            calls bv.Serialize()
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BVAlgebra.DeserializePredicate(System.String)">
            <summary>
            calls BV.Deserialize(s)
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BREX">
            <summary>
            Base class to represent Boolean combinations of regular expressions
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREX.CanBeOptimized">
            <summary>
            Returns true if an optimized DFA can be constructed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BREX.Optimize">
            <summary>
            Construct an optimized DFA.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREX.Equals(System.Object)">
            <summary>
            Value equality
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREX.GetHashCode">
            <summary>
            Hashcode of value
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BREX.description">
            <summary>
            cached description
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREX.Description">
            <summary>
            Description of this Boolean expression of regexes
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREX.Manager">
            <summary>
            gets the manager
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREX.Name">
            <summary>
            Gets the IsMatch method identifier for this expression
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BREXLeaf">
            <summary>
            Leaf element of BREX
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BREXLeaf.automaton">
            <summary>
            The underlying DFA
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXLeaf.CreateAutomaton">
            <summary>
            Returns true if DFA creation succeeds within the required state bounds
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BREXLike">
            <summary>
            Represents a like pattern
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXLike.Manager">
            <summary>
            gets the manager
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BREXLike.like">
            <summary>
            like pattern with escape character
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BREXLike.manager">
            <summary>
            The manager
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXLike.#ctor(Microsoft.Automata.BREXManager,System.String,System.Char)">
            <summary>
            Construct a literal automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXLike.ToString">
            <summary>
            Display the literal Boolean regular expression
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXLike.Equals(System.Object)">
            <summary>
            Value equality
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXLike.GetHashCode">
            <summary>
            Hashcode of value
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BREXRegex">
            <summary>
            Represents a .NET regex pattern
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXRegex.Manager">
            <summary>
            gets the manager
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BREXRegex.regex">
            <summary>
            A .NET regex pattern with options
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BREXRegex.manager">
            <summary>
            The manager
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXRegex.#ctor(Microsoft.Automata.BREXManager,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Construct a literal automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXRegex.ToString">
            <summary>
            Display the literal Boolean regular expression
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXRegex.Equals(System.Object)">
            <summary>
            Value equality
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXRegex.GetHashCode">
            <summary>
            Hashcode of value
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BREXComplement">
            <summary>
            Represents the complement of a Boolean regular expression
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXComplement.Expr">
            <summary>
            The expression being negated
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXComplement.Manager">
            <summary>
            gets the manager
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXComplement.#ctor(Microsoft.Automata.BREX)">
            <summary>
            Construct a literal automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXComplement.ToString">
            <summary>
            Display this Boolean regular expression.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXComplement.Equals(System.Object)">
            <summary>
            Value equality
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXComplement.GetHashCode">
            <summary>
            Hashcode of value
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXComplement.CanBeOptimized">
            <summary>
            Returns true if Expr can be optimized
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.BREXConjunction">
            <summary>
            Represents the conjunction of two Boolean regular expressions
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXConjunction.First">
            <summary>
            The first conjunct
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXConjunction.Second">
            <summary>
            The second conjunct
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXConjunction.Manager">
            <summary>
            gets the manager
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXConjunction.#ctor(Microsoft.Automata.BREX,Microsoft.Automata.BREX)">
            <summary>
            Constructs a conjunction expression
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXConjunction.ToString">
            <summary>
            Displays this Boolean regular expression.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXConjunction.Equals(System.Object)">
            <summary>
            Value equality
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXConjunction.GetHashCode">
            <summary>
            Hashcode of value
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BREXDisjunction">
            <summary>
            Represents the disjunction of two Boolean regular expressions
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXDisjunction.First">
            <summary>
            The first disjunct
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXDisjunction.Second">
            <summary>
            The second disjunct
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXDisjunction.Manager">
            <summary>
            gets the manager
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXDisjunction.#ctor(Microsoft.Automata.BREX,Microsoft.Automata.BREX)">
            <summary>
            Constructs a disjunction expression
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXDisjunction.ToString">
            <summary>
            Displays this Boolean regular expression.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXDisjunction.Equals(System.Object)">
            <summary>
            Value equality
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXDisjunction.GetHashCode">
            <summary>
            Hashcode of value
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BREXManager">
            <summary>
            Manages BREX expressions
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BREXManager.boolRegExp2name">
            <summary>
            BoolRegExp to name dictionary
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BREXManager.index">
            <summary>
            Index appended to different macher method names
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXManager.MatcherPrefix">
            <summary>
            prefix of generated matcher names
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXManager.Solver">
            <summary>
            Converter for regexes
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXManager.LikeConverter">
            <summary>
            Converter for Like expressions
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXManager.AddBoolRegExp(Microsoft.Automata.BREX)">
            <summary>
            Add BREX expression to the pool of existing ones, returns a name that will identify the expression.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXManager.CppStringTypeName">
            <summary>
            Used in C++ for string type
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXManager.MaxNrOfStates">
            <summary>
            The maximum number of states allowed in a generated automaton.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BREXManager.Timeout">
            <summary>
            Timeout for automata constructions.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXManager.#ctor(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Constructs an instance of the manager
            </summary>
            <param name="matcherPrefix">prefix of generated matcher method names, default is "Matcher"</param>
            <param name="cppStringTypeName">identifier in C++ for string type, default is "FString"</param>
            <param name="maxNrOfStates">maximum number of allowed states in a generated automaton, default is 1000, 0 or negative number implies there is no bound</param>
            <param name="timeout">timeout in ms for automata constructions, default is 1000, 0 or negative number implies there is no bound</param>
        </member>
        <member name="M:Microsoft.Automata.BREXManager.GenerateCpp">
            <summary>
            Generate text representing c++ code from the automata text template
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXManager.MkLike(System.String,System.Char)">
            <summary>
            Creates a basic BoolRegExp for like expression.
            </summary>
            <param name="pattern">like pattern</param>
            <param name="escape">escape character, default is '\0'</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BREXManager.MkRegex(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Creates a basic BoolRegExp for regex expression.
            </summary>
            <param name="pattern">.NET regex pattern</param>
            <param name="options">regex options, default is 'RegexOptions.None'</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BREXManager.MkAnd(Microsoft.Automata.BREX,Microsoft.Automata.BREX)">
            <summary>
            Creates a conjunction
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXManager.MkOr(Microsoft.Automata.BREX,Microsoft.Automata.BREX)">
            <summary>
            Creates a disjunction
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BREXManager.MkNot(Microsoft.Automata.BREX)">
            <summary>
            Creates a complement
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BDDHelperPredicates">
            <summary>
            Helper predicates generated from BDDs
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BDDHelperPredicates.Predicate">
            <summary>
            Helper predicate
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDDHelperPredicates.Predicate.Name">
            <summary>
            method name
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDDHelperPredicates.Predicate.Body">
            <summary>
            method body
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDDHelperPredicates.helperPredicates">
            <summary>
            list of helper predicates
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDDHelperPredicates.predicateCache">
            <summary>
            predicate cache
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDDHelperPredicates.solver">
            <summary>
            character solver
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDDHelperPredicates.ascii">
            <summary>
            BDD representing ascii characters
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDDHelperPredicates.optimzeForASCIIinput">
            <summary>
            if true then optimize for ascii
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BDDHelperPredicates.prefix">
            <summary>
            prefix of all helper method names, default is "Regex"
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDHelperPredicates.#ctor(Microsoft.Automata.CharSetSolver,System.Boolean,System.String)">
            <summary>
            Create instance of HelperPredicates 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDHelperPredicates.GenerateCodeForBDD(System.Text.StringBuilder,Microsoft.Automata.BDD,System.String)">
            <summary>
            Generate method code for a given BDD with given methid as method name
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDHelperPredicates.GeneratePredicate(Microsoft.Automata.BDD)">
            <summary>
            Generate a string representing a predicate that is equivalent to the BDD pred
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDHelperPredicates.GeneratePredicateHelper(Microsoft.Automata.BDD)">
            <summary>
            Predicate for the BDD predicate
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDHelperPredicates.Format(System.Func{System.String,System.String,System.String})">
            <summary>
            Format name and body
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDHelperPredicates.RangesToCode(System.Tuple{System.UInt32,System.UInt32}[])">
            <summary>
            Convert the pairs into a range condition expression
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDHelperPredicates.RangesToCode2(System.Tuple{System.UInt32,System.UInt32}[],System.Int32,System.Int32)">
            <summary>
            Convert the pairs into a range condition expression helper function
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BDDHelperPredicates.RangesToCode3(System.Tuple{System.UInt32,System.UInt32}[],System.Int32,System.Int32)">
            <summary>
            Helper method for ranges to code generation that uses binary search in intervals
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1">
            <summary>
            Converts like expressions to Automata
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1.ILikeNode">
            <summary>
            Automaton converter.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.ILikeNode.ToAutomaton(Microsoft.Automata.RegexToAutomatonBuilder{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode,`0},Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Convert to automaton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeRoot">
            <summary>
            Root node of a Like node.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeRoot.children">
            <summary>
            children of the node
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeRoot.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode})">
            <summary>
            Construct a root node with given child nodes
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeRoot.ToAutomaton(Microsoft.Automata.RegexToAutomatonBuilder{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode,`0},Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Convert to Automaton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeString">
            <summary>
            Represents a string element.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeString.chars">
            <summary>
            characters in the string
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeString.#ctor(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Create a string element with given characters
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeString.ToAutomaton(Microsoft.Automata.RegexToAutomatonBuilder{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode,`0},Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Convert to automaton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharSet">
            <summary>
            Represents a character set.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharSet.set">
            <summary>
            characters in the set
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharSet.negate">
            <summary>
            flag is true if the set is negated
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharSet.#ctor(System.Collections.Generic.IEnumerable{System.Char},System.Boolean)">
            <summary>
            Construct a character set with the given characters
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharSet.ToAutomaton(Microsoft.Automata.RegexToAutomatonBuilder{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode,`0},Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Convert to automaton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharRange">
            <summary>
            Represents a character range.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharRange.start">
            <summary>
            start and end elements
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharRange.end">
            <summary>
            start and end elements
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharRange.negate">
            <summary>
            true if the range is negated
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharRange.#ctor(System.Char,System.Char,System.Boolean)">
            <summary>
            Constructs a range
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeCharRange.ToAutomaton(Microsoft.Automata.RegexToAutomatonBuilder{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode,`0},Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Convert to automaton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeAny">
            <summary>
            Represents an any node.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeAny.ToAutomaton(Microsoft.Automata.RegexToAutomatonBuilder{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode,`0},Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Convert to automaton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeWildcard">
            <summary>
            Represents an wildcard.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeWildcard.ToAutomaton(Microsoft.Automata.RegexToAutomatonBuilder{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode,`0},Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Convert to automaton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeFalse">
            <summary>
            Represents a false node
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.LikeFalse.ToAutomaton(Microsoft.Automata.RegexToAutomatonBuilder{Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode,`0},Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Convert to automaton
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.solver">
            <summary>
            Underlying character solver.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.LikePatternToAutomatonConverter`1.builder">
            <summary>
            Underlying regex to automaton builder.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.#ctor(Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Create instance of LikeToAutomatonConverter for a given character solver.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.Convert(System.String,System.Nullable{System.Char})">
            <summary>
            Convert expression to automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.ParseString(System.CharEnumerator,System.Nullable{System.Char})">
            <summary>
            Like node parser from string
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.ParseCharClass(System.CharEnumerator,System.Nullable{System.Char})">
            <summary>
            Like node parser from character class
            </summary>
        </member>
        <member name="M:Microsoft.Automata.LikePatternToAutomatonConverter`1.TokenToAutomaton(Microsoft.Automata.LikePatternToAutomatonConverter{`0}.ILikeNode)">
            <summary>
            Convert token to auomaton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BV">
            <summary>
            Represents a bitvector
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.#ctor(System.UInt64,System.UInt64[])">
            <summary>
            Constructs a bitvector
            </summary>
            <param name="first">first 64 bits</param>
            <param name="more">remaining bits in 64 increments</param>
        </member>
        <member name="M:Microsoft.Automata.BV.op_BitwiseAnd(Microsoft.Automata.BV,Microsoft.Automata.BV)">
            <summary>
            Bitwise AND
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.op_BitwiseOr(Microsoft.Automata.BV,Microsoft.Automata.BV)">
            <summary>
            Bitwise OR
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.op_ExclusiveOr(Microsoft.Automata.BV,Microsoft.Automata.BV)">
            <summary>
            Bitwise XOR
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.op_OnesComplement(Microsoft.Automata.BV)">
            <summary>
            Bitwise NOT
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.op_LessThan(Microsoft.Automata.BV,Microsoft.Automata.BV)">
            <summary>
            less than
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.op_GreaterThan(Microsoft.Automata.BV,Microsoft.Automata.BV)">
            <summary>
            greater than
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.op_LessThanOrEqual(Microsoft.Automata.BV,Microsoft.Automata.BV)">
            <summary>
            less than or equal
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.op_GreaterThanOrEqual(Microsoft.Automata.BV,Microsoft.Automata.BV)">
            <summary>
            greater than or equal
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.ToString">
            <summary>
            Shows the serialized representation
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BV.Serialize">
            <summary>
            Serialize BV into a string of hexadecimal numerals, separated by '.', 
            each numeral representing an unsigned 64-bit integer in hexadecimal using lowercase a-f
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BV.Deserialize(System.String)">
            <summary>
            Deserialize BV from given string that was produced by Serialize
            </summary>
            <param name="s">BV in serialized form</param>
        </member>
        <member name="T:Microsoft.Automata.BitWidth">
            <summary>
            Number of bits used in bitvectors.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BitWidth.BV7">
            <summary>
            7 bit ASCII encoding
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BitWidth.BV8">
            <summary>
            8 bit Extended ASCII encoding
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BitWidth.BV16">
            <summary>
            16 bit bit-vector encoding
            </summary>
        </member>
        <member name="F:Microsoft.Automata.BitWidth.BV32">
            <summary>
            32 bit bit-vector encoding
            </summary>
        </member>
        <member name="T:Microsoft.Automata.CharacterEncodingTool">
            <summary>
            Provides functionality for character encodings. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharacterEncodingTool.Truncate(Microsoft.Automata.BitWidth)">
            <summary>
            Maps ASCII to 7, extended ASCII to 8, and other encodings to 16.
            Throws AutomataException if IsSpecified(encoding) is false.
            </summary>
            <param name="encoding"></param>
            <returns>either 7, 8, or 16</returns>
        </member>
        <member name="M:Microsoft.Automata.CharacterEncodingTool.IsSpecified(Microsoft.Automata.BitWidth)">
            <summary>
            Returns true iff encoding equals to one of the enums in CharacterEncoding.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.CharSetSolver">
            <summary>
            Provides functionality to build character sets, to perform boolean operations over character sets,
            and to construct an SFA over character sets from a regex.
            Character sets are represented by bitvector sets.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CharSetSolver.RegexConverter">
            <summary>
            Underlying regex converter.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.#ctor">
            <summary>
            Construct the solver for BitWidth.BV16
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.#ctor(Microsoft.Automata.BitWidth)">
            <summary>
            Construct a character set solver for the given character encoding (nr of bits).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.Choose(Microsoft.Automata.Chooser,Microsoft.Automata.BDD)">
            <summary>
            Choose a member of the set. Assumes that the set is nonempty.
            </summary>
            <param name="chooser">element chooser</param>
            <param name="set">given set</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkCharConstraint(System.Char,System.Boolean)">
            <summary>
            Make a character containing the given character c.
            If c is a lower case or upper case character and ignoreCase is true
            then add both the upper case and the lower case characters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkCharSetFromRange(System.Char,System.Char)">
            <summary>
            Make a CharSet from all the characters in the range from m to n. 
            Returns the empty set if n is less than m
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkCharSetFromRanges(System.Collections.Generic.IEnumerable{System.Tuple{System.UInt32,System.UInt32}})">
            <summary>
            Make a character set that is the union of the character sets of the given ranges.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkCharSetFromRanges(System.Char[])">
            <summary>
            Make a character set that is the union of the character sets of ranges, there must me an even number of characters definining ranges.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkCharSetFromRegexCharClass(System.String)">
            <summary>
            Make a character set from a regex character class, e.g., 
            "\w" is the character class of word-letter characters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkRangeConstraint(System.Char,System.Char,System.Boolean)">
            <summary>
            Make a character set of all the characters in the interval from c to d.
            If ignoreCase is true ignore cases for upper and lower case characters by including both versions.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkBddForIntRanges(System.Collections.Generic.IEnumerable{System.Int32[]})">
            <summary>
            Make a BDD encoding of k least significant bits of all the integers in the ranges
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkRangesConstraint(System.Boolean,System.Collections.Generic.IEnumerable{System.Char[]})">
            <summary>
            Make a character set constraint of all the characters in the character ranges.
            If ignoreCase is true ignore cases for upper and lower case characters by including both versions.
            It is assumed that each elemet in ranges is an array of 2 characters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.SerializeCompact(Microsoft.Automata.BDD)">
            <summary>
            Represent the set as an integer array.
            Assumes that the bdd has less than 2^14 nodes and at most 16 variables.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.SerializeCompact2(Microsoft.Automata.BDD)">
            <summary>
            Represent the set as an integer array.
            Assumes that the bdd has at most 2^14 nodes and at most 16 variables.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.DeserializeCompact(System.Int32[])">
            <summary>
            Recreates a BDD from an int array that has been created using SerializeCompact
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.DeserializeCompact2(System.Int32[])">
            <summary>
            Recreates a BDD from an int array that has been created using SerializeCompact
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.PrettyPrint(Microsoft.Automata.BDD)">
            <summary>
            Provides a regex-character-class view of a character set.
            For example if the set contains characters 'a' to 'd' and 'x', and digits '5' to '8' then
            PrettyPrint(set) returns the string "[a-dx5-8]".
            </summary>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.PrettyPrint(Microsoft.Automata.BDD,System.Func{Microsoft.Automata.BDD,System.String})">
            <summary>
            Provides a regex-character-class view of a character set.
            For example if the set contains characters 'a' to 'd' and 'x', and digits '5' to '8' then
            PrettyPrint(set) returns the string "[a-dx5-8]".
            </summary>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Automata.CharSetSolver.Chooser">
            <summary>
            Gets the element chooser of this character set solver.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.Choose(Microsoft.Automata.BDD)">
            <summary>
            Choose a random element from the set. Assumes that the set is not empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ChooseUniformly(Microsoft.Automata.BDD)">
            <summary>
            Choose a random character from the set uniformly, all characters have equal probability of getting chosen. Assumes that the set is not empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ChooseString(System.Collections.Generic.IEnumerable{Microsoft.Automata.BDD})">
            <summary>
            Choose a random string such that the i'th character is a member of the 
            i'th character set in the enumeration.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ConvertToRegex(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.Collections.Generic.List{System.Int32})">
            <summary>
            Convert an Automaton into a equivalent .NET regex.
            </summary>
            <param name="automaton">automaton over charsets</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ConvertToRegex(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Convert an Automaton into a equivalent .NET regex.
            </summary>
            <param name="automaton">automaton over charsets</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.Convert(System.String)">
            <summary>
            Convert a .NET regex into an equivalent automaton whose moves are labeled by character sets.
            Uses System.Text.RegularExpressions.RegexOptions.None for interpreting the regex.
            </summary>
            <param name="regex">.NET regex pattern</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.Convert(System.String,System.Text.RegularExpressions.RegexOptions,System.Boolean)">
            <summary>
            Convert a .NET regex into an equivalent automaton whose moves are labeled by character sets.
            </summary>
            <param name="regex">.NET regex pattern</param>
            <param name="options">regex options for interpreting the regex, default is System.Text.RegularExpressions.RegexOptions.Singleline</param>
            <param name="keepBoundaryStates">used for testing purposes, when true boundary states are not removed, default is false</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.GenerateMember(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Generate a random string accepted by the automaton.
            Assumes that the automaton accepts at least one string.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.Accepts(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.String)">
            <summary>
            Returns true iff the automaton aut accepts the string s.
            </summary>
            <param name="aut">given automaton</param>
            <param name="s">given string</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.GenerateMemberUniformly(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Generates a random string accepted by the automaton.
            The distribution is uniform: all strings accepted by the automaton are equally likely to be generated.
            </summary>
            <param name="aut">loopfree and deterministic automaton</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ConvertFromCharSet(Microsoft.Automata.BDD)">
            <summary>
            Identity function, returns s.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CharSetSolver.CharSetProvider">
            <summary>
            Returns this character set solver.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.MkCharPredicate(System.String,Microsoft.Automata.BDD)">
            <summary>
            Returns pred.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ShowGraph(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.String)">
            <summary>
            Save the automaton in dgml format and open the dgml file in a new process.
            The dgml file is opened in a new window in VS.
            </summary>
            <param name="aut">the automaton</param>
            <param name="name">a name for the dgml file</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ShowDAG(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.String)">
            <summary>
            Shows the probabilities of choosing different moves according to uniform distribution of accepted strings.
            Saves the automaton in dgml format and opens the dgml file in a new process.
            The dgml file is opened in a new window in VS. 
            The automaton must be loopfree and deterministic.
            </summary>
            <param name="aut">the automaton</param>
            <param name="name">a name for the dgml file</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.SaveAsDot(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.String,System.String)">
            <summary>
            Save the automaton in dot format in the given file.
            </summary>
            <param name="aut">the automaton</param>
            <param name="name">a name for the dot file</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.SaveAsDgml(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.String)">
            <summary>
            Save the automaton in dgml format in the given file.
            </summary>
            <param name="aut">the automaton</param>
            <param name="name">a name for the dgml file</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.SerializeDAG(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Create a string encoding of the given automaton with probabilities.
            </summary>
            <param name="aut">deterministic and loopfree automaton</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.DeserializeDAG(System.String)">
            <summary>
            Recreate an automaton from a string that has been produced with SerializeDAG.
            </summary>
            <param name="dag">string encoding of a deterministic and loopfree automaton with probabilities</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.SerializeAutomaton(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Create a string encoding of the given automaton with probabilities.
            </summary>
            <param name="aut">deterministic and loopfree automaton</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.DeserializeAutomaton(System.String)">
            <summary>
            Recreate an automaton from a string that has been produced with SerializeDAG.
            </summary>
            <param name="serialDesc">string encoding of a deterministic and loopfree automaton with probabilities</param>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ComputeDomainSize(Microsoft.Automata.BDD)">
            <summary>
            Calculate the number of elements in the set.
            </summary>
            <param name="set">the given set</param>
            <returns>the cardinality of the set</returns>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.IsSingleton(Microsoft.Automata.BDD)">
            <summary>
            Returns true iff the set contains exactly one element.
            </summary>
            <param name="set">the given set</param>
            <returns>true iff the set is a singleton</returns>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ToRanges(Microsoft.Automata.BDD,System.Int32)">
            <summary>
            Convert the set into an equivalent array of ranges. The ranges are nonoverlapping and ordered.
            If limit > 0 then returns null if the total number of ranges exceeds limit.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.GetRangeCount(Microsoft.Automata.BDD)">
            <summary>
            Convert the set into an equivalent array of ranges and return the number of such ranges.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.GenerateAllElements(Microsoft.Automata.BDD,System.Boolean)">
            <summary>
            Generate all characters that are members of the set in alphabetical order, smallest first, provided that inReverseOrder is false.
            </summary>
            <param name="set">the given set</param>
            <param name="inReverseOrder">if true the members are generated in reverse alphabetical order with the largest first, otherwise in alphabetical order</param>
            <returns>enumeration of all characters in the set, the enumeration is empty if the set is empty</returns>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.GetMax(Microsoft.Automata.BDD)">
            <summary>
            Get the lexicographically maximum bitvector in the set. Assumes that the set is nonempty.
            </summary>
            <param name="set">the given nonempty set</param>
            <returns>the lexicographically largest bitvector in the set</returns>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.GetCoveredStates(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.String,System.Boolean)">
            <summary>
            Returns the set of states touched by the input string
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.GetCoveredMoves(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.String)">
            <summary>
            Returns the set of states touched by the input string
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.ReadFromRanges(System.Int32,System.Int32[],System.Collections.Generic.IEnumerable{System.Int32[]})">
            <summary>
            Each transition has the form int[]{fromState, intervalStart, intervalEnd, toState}.
            If intervalStart = intervalEnd = -1 then this is an epsilon move.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CharSetSolver.LShiftRight(Microsoft.Automata.BDD)">
            <summary>
            Shift right and set the leftmost bit to 0.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Chooser">
            <summary>
            Random number chooser.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Chooser.randomNumberGenerator">
            <summary>
            The RNGCryptoServiceProvider object the Chooser uses.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Chooser.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Automata.Chooser" /> class.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Chooser.Choose(System.Int32)">
            <summary>
            Returns a nonnegative random number less than the specified maximum.
            </summary>
            <param name="n">The exclusive upper bound of the random number to be generated. n must be
            greater than or equal to zero.</param>
            <returns>An integer greater than or equal to zero, and less than n.</returns>
        </member>
        <member name="M:Microsoft.Automata.Chooser.ChooseBV32">
            <summary>
            Choose a random uint.
            </summary>
            <returns>A random uint equal to or greater than 0 and less than or equal to uint.MaxValue.</returns>
        </member>
        <member name="M:Microsoft.Automata.Chooser.ChooseBV64">
            <summary>
            Choose a random ulong.
            </summary>
            <returns>A random ulong equal to or greater than 0 and less than or equal to ulong.MaxValue.</returns>
        </member>
        <member name="M:Microsoft.Automata.Chooser.ChooseTrueOrFalse">
            <summary>
            Choose true or false randomly.
            </summary>
            <returns>True or false.</returns>
        </member>
        <member name="M:Microsoft.Automata.Chooser.ChooseDouble">
            <summary>
            Returns a random number between 0.0 and 1.0.
            </summary>
            <returns>A double-precision floating point number greater than or equal to 0.0, and less
            than 1.0.</returns>
        </member>
        <member name="M:Microsoft.Automata.Chooser.GetMostSignificantBit(System.UInt32)">
            <summary>
            Calculates the value of the most significant bit in a positive integer.
            </summary>
            <param name="n">The positive integer of which the 
            value of the most significant bit is to be calculated.</param>
            <returns>The value of the most significant bit.</returns>
        </member>
        <member name="T:Microsoft.Automata.CounterOp">
            <summary>
            Counter update operations. 
            Counter opertions other that NOOP (that = 0) can be combined with bitwise-or.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CounterOp.SET0">
            <summary>
            Target counter is set to 0
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CounterOp.SET1">
            <summary>
            Target counter is set to 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CounterOp.EXIT">
            <summary>
            Source counter greater or equal lower bound is checked
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CounterOp.INCR">
            <summary>
            Source counter less than upper bound is checked and the value is incermented by 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CounterOp.EXIT_SET0">
            <summary>
            Source counter greater or equal lower bound is checked and target counter is set to 0
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CounterOp.EXIT_SET1">
            <summary>
            Source counter greater or equal lower bound is checked and target counter is set to 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CounterOp.COPY">
            <summary>
            Source counter greater or equal lower bound is checked and target counter is set to 1
            </summary>
        </member>
        <member name="T:Microsoft.Automata.CounterOperation">
            <summary>
            Operation over counters
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CounterOperation.Counter">
            <summary>
            counter reference
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CounterOperation.OperationKind">
            <summary>
            what kind of operation 
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BoundedCounter">
            <summary>
            Represents a counter with finite lower and upper bounds
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BoundedCounter.ContainsSubCounter(Microsoft.Automata.ICounter)">
            <summary>
            The counter is intended to be used when subcounters (nested counters) do not occur.
            This function returns false always.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ConditionalDerivative`1">
            <summary>
            Conditional derivative
            </summary>
            <typeparam name="S">input predicate type</typeparam>
        </member>
        <member name="M:Microsoft.Automata.ConditionalDerivative`1.Compose(Microsoft.Automata.ConditionalDerivative{`0})">
            <summary>
            If null is returned then the composition is not enabled
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ConsList`1">
            <summary>
            Simply linked list of elements of type E. 
            </summary>
        </member>
        <member name="F:Microsoft.Automata.ConsList`1.first">
            <summary>
            The first element in the list
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ConsList`1.First">
            <summary>
            Gets the first element in the list
            </summary>
        </member>
        <member name="F:Microsoft.Automata.ConsList`1.rest">
            <summary>
            The rest of the list (null if the rest is empty)
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ConsList`1.Rest">
            <summary>
            Gets or sets the rest of the list. Value is null if the rest is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ConsList`1.#ctor(`0,Microsoft.Automata.ConsList{`0})">
            <summary>
            Make a new list whose first element is first and whose rest is rest (rest may be null)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ConsList`1.Count">
            <summary>
            Counts the number of elements in the list.
            Assumes that the list is not circular, or else the method will not terminate.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ConsList`1.ToArray(System.Boolean)">
            <summary>
            Returns the nonempty array of the elements in the list.
            Assumes that the list is not circular, or else the method will not terminate.
            </summary>
            <param name="inreverse">if true the elements are in reverse order</param>
        </member>
        <member name="M:Microsoft.Automata.ConsList`1.#ctor(`0)">
            <summary>
            Creates a singleton list.
            </summary>
            <param name="elem">the element of the list</param>
        </member>
        <member name="M:Microsoft.Automata.ConsList`1.Create(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a list of the elements in the enumeration.
            Returns null if the enumeration is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ConsList`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            Tests if there exists an element e in the list such that check(e) is true
            </summary>
            <param name="check">Boolean function to perform the test</param>
            <returns>true iff there exists an element e in the list such that check(e) is true</returns>
        </member>
        <member name="M:Microsoft.Automata.ConsList`1.ToString">
            <summary>
            Display the list as [elem_0,elem_1,...,elem_k]. Ends with "..." if the list is circular.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ConsList`1.Reverse">
            <summary>
            Returns a new list that is the reverse of the list.
            Assumes that this list is not circular, or else the method will not terminate.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.SimpleList`1">
            <summary>
            A simple list of elements of type E. 
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SimpleList`1.Empty">
            <summary>
            Empty simple list.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SimpleList`1.IsNonempty">
            <summary>
            Returns true iff the list is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SimpleList`1.Count">
            <summary>
            Returns the number of elements in this list.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SimpleList`1.IndexOf(`0)">
            <summary>
            Returns the position of the last occurrence of elem, or -1 if elem does not occur in the list.
            Indexing starts with 0.
            </summary>
            <param name="elem"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SimpleList`1.Contains(`0)">
            <summary>
            Returns true iff the list contains elem.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SimpleList`1.Append(`0)">
            <summary>
            Creates a new simple list by appending elem at the end of this list.
            </summary>
            <param name="elem">element to append</param>
        </member>
        <member name="M:Microsoft.Automata.SimpleList`1.Append(`0[])">
            <summary>
            Creates a new simple list by appending elems at the end of this list.
            </summary>
            <param name="elems">elements to append</param>
        </member>
        <member name="M:Microsoft.Automata.SimpleList`1.Append(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new simple list by appending elems at the end of this list.
            </summary>
            <param name="elems">elements to append</param>
        </member>
        <member name="M:Microsoft.Automata.SimpleList`1.ToArray">
            <summary>
            Convert the list into an array
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SimpleList`1.Last">
            <summary>
            Returns the last element. Returns default(E) if the list is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SimpleList`1.Butlast">
            <summary>
            Returns the list without the last element. Returns null if the list is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SimpleStack`1.#ctor">
            <summary>
            Creates a new empty stack.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SimpleStack`1.IsEmpty">
            <summary>
            Returns true iff the stack is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SimpleStack`1.IsNonempty">
            <summary>
            Returns true iff the stack is nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SimpleStack`1.Push(`0)">
            <summary>
            Pushes a new element to the top of the stack.
            </summary>
            <param name="elem">element to be pushed</param>
        </member>
        <member name="M:Microsoft.Automata.SimpleStack`1.PushAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Pushes all elements to the top of the stack.
            </summary>
            <param name="newelems">elements to be pushed</param>
        </member>
        <member name="M:Microsoft.Automata.SimpleStack`1.Pop">
            <summary>
            Pops the top element of the stack and returns it.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Automata.CountingAutomaton`1.countingStates">
            <summary>
            Maps a counting state to its associated counter
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CountingAutomaton`1.stateMap">
            <summary>
            Maps a state to the underlying regex AST node
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CountingAutomaton`1.counters">
            <summary>
            Array of all counters, counter with identifier i is the element counters[i]
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.GetFinalStateCondition(System.Int32)">
            <summary>
            Returns the final state condition of a final state. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.IsCountingState(System.Int32)">
            <summary>
            Returns true if q is a counting-state (q is associated with a counter)
            </summary>
            <param name="q">given state</param>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.IsSingletonCountingState(System.Int32)">
            <summary>
            Returns true if q is a counting-state that only needs one copy of the counter.
            A sufficient condition is when no incoming transition overlaps with any loop.
            </summary>
            <param name="q">given state</param>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.GetCounter(System.Int32)">
            <summary>
            Returns the counter associated with the state q.
            The state q must be a couting state.
            </summary>
            <param name="q">given counting state</param>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.GetCounterWithId(System.Int32)">
            <summary>
            Returns the counter with the given id
            </summary>
            <param name="q">given counter id</param>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.TryGetCounter(System.Int32,Microsoft.Automata.ICounter@)">
            <summary>
            Returns true if q is a counting state and outputs the counter of q.
            Returns false otherwise and sets counter to null.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.CompileOpt(System.Int32,System.Boolean)">
            <summary>
            Optimized version of the compile function (merging transitions with same update).
            </summary>
            <param name="mode">0 - generate HIGH, MIDDLE, LOW always, 1 - generate MIDDLE or LOW only if needed</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.GenerateMinterms(Microsoft.Automata.ConsList{System.Int32},System.Collections.Generic.List{System.Int32},Microsoft.Automata.Move{System.Tuple{Microsoft.Automata.Maybe{`0},Microsoft.Automata.Sequence{Microsoft.Automata.CounterOperation}}}[],System.Int32,Microsoft.Automata.CsConditionSeq)">
            <summary>
            Creates counter minterms for the given set of counting states and input predicate.
            </summary>
            <param name="list">list of counting states, possibly empty i.e. null</param>
            <param name="a">input predicate</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.IsMatch(System.String)">
            <summary>
            Returns true if the input string is accepted by this counting automaton
            </summary>
            <param name="input">given input string</param>
        </member>
        <member name="M:Microsoft.Automata.CountingAutomaton`1.GetCounterUpdate(System.Int32,`0,Microsoft.Automata.CsConditionSeq)">
            <summary>
            Creates counter minterms for the given set of counting states and input predicate.
            </summary>
            <param name="list">list of counting states, possibly empty i.e. null</param>
            <param name="a">input predicate</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.CABA`1">
            <summary>
            Dummy Boolean algebra use only for customized pretty printing of CountingAutomaton transition labels
            </summary>
        </member>
        <member name="T:Microsoft.Automata.CsAutomatonOpt`1">
            <summary>
            Counting-set Automaton Optimized
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomatonOpt`1.Init``1(``0[],``0)">
            <summary>
            Underlying Cartesian product algebra
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomatonOpt`1.GetOriginalInitialState">
            <summary>
            Gets the number of counters.
            All counters are numbered from 0 to NrOfCounters-1.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomatonOpt`1.DescribeState(System.Int32)">
            <summary>
            Describe the state information, including original states if determinized, as well as counters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomatonOpt`1.DescribeStartLabel">
            <summary>
            Describe if the initial state is associuated with a counter, if so then set it to {0}
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomatonOpt`1.GetCountersOfState(System.Int32)">
            <summary>
            Get the active counters associated with the given state.
            The set is empty if this state is not asscociated with any counters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomatonOpt`1.Delta(System.Int32)">
            <summary>
            Compute the target state for source state q and input character c.
            All uses of Delta must be inlined for efficiency. 
            This is the purpose of the MethodImpl(MethodImplOptions.AggressiveInlining) attribute.
            </summary>
            <param name="c">input character</param>
            <param name="q">state id of source regex</param>
            <param name="regex">target regex</param>
            <returns>state id of target regex</returns>
        </member>
        <member name="T:Microsoft.Automata.CsAutomaton`1">
            <summary>
            Counting-set Automaton
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsAutomaton`1.ProductAlgebra">
            <summary>
            Underlying Cartesian product algebra
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomaton`1.DescribeState(System.Int32)">
            <summary>
            Describe the state information, including original states if determinized, as well as counters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomaton`1.DescribeStartLabel">
            <summary>
            Describe if the initial state is associuated with a counter, if so then set it to {0}
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomaton`1.GetCountersOfState(System.Int32)">
            <summary>
            Get the active counters associated with the given state.
            The set is empty if this state is not asscociated with any counters.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsAutomaton`1.NrOfCounters">
            <summary>
            Get the total number of counters
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAutomaton`1.GetCounterInfo(System.Int32)">
            <summary>
            Get the counter info associated with the given counter id
            </summary>
            <param name="counterId">must be a number between 0 and NrOfCounters-1</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.CsAutomaton`1.IsFinalCounter(System.Int32)">
            <summary>
            Returns true if the given counter is a final counter, thus, in final state 
            contributes to the overall final state condition.
            </summary>
            <param name="counterId">must be a number between 0 and NrOfCounters-1</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.NOOP">
            <summary>
            No update
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.ADD0">
            <summary>
            Target counter is set to 0
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.ADD1">
            <summary>
            Target counter is set to 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.ADD01">
            <summary>
            Target counter is set to 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.EXIT">
            <summary>
            Source counter greater or equal lower bound is checked
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.INCR">
            <summary>
            Source counter less than upper bound is checked and the value is incermented by 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.INCR0">
            <summary>
            Source counter less than upper bound is checked and the value is incermented by 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.INCR1">
            <summary>
            Source counter less than upper bound is checked and the value is incermented by 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.INCR01">
            <summary>
            Source counter less than upper bound is checked and the value is incermented by 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.ADD0_EXIT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.ADD1_EXIT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.ADD01_EXIT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.INCR_EXIT">
            <summary>
            Source counter is in the middle
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.INCR0_EXIT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.INCR1_EXIT">
             <summary>
            
             </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.INCR01_EXIT">
             <summary>
            
             </summary>
        </member>
        <member name="F:Microsoft.Automata.CsUpdate.COPY">
            <summary>
            Source counter greater or equal lower bound is checked and target counter is set to 1
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.FALSE">
            <summary>
            Unsatisfiable condition
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.LOW">
            <summary>
            Nonempty and all elements are below lower bound
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.MIDDLE">
            <summary>
            Some element is at least lower bound but it is not the only element if it is the upper bound
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.CANLOOP">
            <summary>
            The condition when loop increment is possible, same as LOW|MIDDLE
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.HIGH">
            <summary>
            Singleton set containing the upper bound
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.LOWorHIGH">
            <summary>
            All elements are below lower bound, or singleton set containing the upper bound, same as LOW|HIGH
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.CANEXIT">
            <summary>
            The condition when loop exit is possible, same as MIDDLE|HIGH
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.NONEMPTY">
            <summary>
            Set is nonempty, same as LOW|MIDDLE|HIGH
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.EMPTY">
            <summary>
            Set is empty
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.CANNOTEXIT">
            <summary>
            Same as EMPTY|LOW
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.EMPTYorMIDDLE">
            <summary>
            Same as EMPTY|MIDDLE
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.EMPTYorCANLOOP">
            <summary>
            Same as EMPTY|MIDDLE|LOW
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.CANNOTLOOP">
            <summary>
            Same as EMPTY|HIGH
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.EMPTYorHIGHorLOW">
            <summary>
            Same as EMPTY|HIGH|LOW
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.EMPTYorCANEXIT">
            <summary>
            Same as EMPTY|HIGH|MIDDLE
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsCondition.TRUE">
            <summary>
            Condition that always holds, same as EMPTY|MIDDLE|HIGH|LOW
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsUpdateSeq.IsNOOP">
            <summary>
            Returns true if all counter operations are NOOP
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsConditionSeq.IsAND">
            <summary>
            Returns true iff this sequence represents a conjunction
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsConditionSeq.Length">
            <summary>
            Number of conditions
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.MkAND(Microsoft.Automata.CsCondition[])">
            <summary>
            Make a sequence that corresponds to the conjunction of the individual counter conditions.
            </summary>
            <param name="vals">i'th element is the i'th counter condition</param>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.MkOR(Microsoft.Automata.CsCondition[])">
            <summary>
            Make a sequence that corresponds to the disjunction of the individual counter conditions.
            </summary>
            <param name="vals">i'th element is the i'th counter condition</param>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.MkTrue(System.Int32)">
            <summary>
            Creates a conjunction with all individual counter conditions being TRUE
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.MkFalse(System.Int32)">
            <summary>
            Creates a disjunction with all individual counter conditions being FALSE
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.MkFalseConj(System.Int32)">
            <summary>
            Creates a conjunction with all individual counter conditions being FALSE
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsConditionSeq.Item(System.Int32)">
            <summary>
            Returns the i'th condition
            </summary>
            <param name="i">must be between 0 and Length-1</param>
        </member>
        <member name="P:Microsoft.Automata.CsConditionSeq.IsSatisfiable">
            <summary>
            If conjunction, returns true if all conditions in the sequence are different from FALSE.
            If disjunction, returns true if some condition in the sequence is different from FALSE
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsConditionSeq.IsValid">
            <summary>
            If conjunction, returns true if all conditions in the sequence are TRUE.
            If disjunction, returns true if some condition in the sequence is TRUE.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.op_BitwiseAnd(Microsoft.Automata.CsConditionSeq,Microsoft.Automata.CsConditionSeq)">
            <summary>
            Create a conjunction sequence of two sequences that represent conjunctions
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.op_BitwiseOr(Microsoft.Automata.CsConditionSeq,Microsoft.Automata.CsConditionSeq)">
            <summary>
            Create a disjunction sequence of two sequences that represent disjunctions
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.op_OnesComplement(Microsoft.Automata.CsConditionSeq)">
            <summary>
            Complement the sequence from OR to AND and vice versa, 
            individual counter conditions are complemented.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.Or(System.Int32,Microsoft.Automata.CsCondition)">
            <summary>
            Update the i'th element to this[i] | cond
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Automata.CsConditionSeq.And(System.Int32,Microsoft.Automata.CsCondition)" -->
        <member name="M:Microsoft.Automata.CsConditionSeq.InitForLow(System.Int32)">
            <summary>
            Creates a conjunction with all individual counter conditions being LOW
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsConditionSeq.CountIndex(System.Int32[])">
            <summary>
            Returns the i'th condition
            </summary>
            <param name="i">must be between 0 and Length-1</param>
        </member>
        <member name="T:Microsoft.Automata.CsPred`1">
            <summary>
            Represents a Boolean cobination of input predicates and counter conditions
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsPred`1.CounterPredicateSize">
            <summary>
            Gets the size of the underlying internal representation of the counter predicate.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CsPred`1.Algebra">
            <summary>
            Gets the algebra of the predicate.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsPred`1.ProjectSecond">
            <summary>
            Project the input predicate
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsPred`1.GetSumOfProducts">
            <summary>
            Enumerate the individual conjuncts of the predicate in DNF form.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsPred`1.ToArray">
            <summary>
            Return all the conjuncts of the predicate in DNF form as an array.
            The DNF may be very large even if CounterPredicateSize is relatively small.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsPred`1.op_BitwiseAnd(Microsoft.Automata.CsPred{`0},Microsoft.Automata.CsPred{`0})">
            <summary>
            Make the conjunction of left with right
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsPred`1.op_BitwiseOr(Microsoft.Automata.CsPred{`0},Microsoft.Automata.CsPred{`0})">
            <summary>
            Make the disjunction of left with right
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsPred`1.op_OnesComplement(Microsoft.Automata.CsPred{`0})">
            <summary>
            Make the negation of the predicate
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsPred`1.CheckSat">
            <summary>
            Returns true if the predicate is satisfiable
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsPred`1.CheckValidity">
            <summary>
            Returns true if the predicate is valid
            </summary>
        </member>
        <member name="T:Microsoft.Automata.CsAlgebra`1">
            <summary>
            Boolean algebra for CsPred predicates
            </summary>
            <typeparam name="T">input predicate type</typeparam>
        </member>
        <member name="F:Microsoft.Automata.CsAlgebra`1.NodeAlgebra">
            <summary>
            Generic BDD algebra use for internal representation
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsAlgebra`1.LeafAlgebra">
            <summary>
            Algebra of T-predicates used for leaves of the generic BDD algebra
            </summary>
        </member>
        <member name="F:Microsoft.Automata.CsAlgebra`1.K">
            <summary>
            Number of counters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.CsAlgebra`1.MkPredicate(`0,Microsoft.Automata.CsConditionSeq)">
            <summary>
            Make a product between leafpred and vals.
            </summary>
            <param name="leafpred">input predicate</param>
            <param name="vals">this is either a conjunction or disjunction of counter conditions</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.CsAlgebra`1.MkPredicate(`0,System.Boolean,Microsoft.Automata.CsCondition[])">
            <summary>
            Make a product between leafpred and vals.
            </summary>
            <param name="leafpred">input predicate</param>
            <param name="vals">sequence of counter conditions</param>
            <param name="isAND">if true then treat vals as a conjunction, else as a disjunction</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Automata.DirectedGraphs.Options.MaxDgmlTransitionLabelLength">
            <summary>
            Maximum length of transiton labels shown in dgml view
            </summary>
        </member>
        <member name="M:Microsoft.Automata.DirectedGraphs.DgmlWriter.AutomatonToDgml``1(System.Int32,Microsoft.Automata.IAutomaton{``0},System.String)">
            <summary>
            Write the automaton in dgml format.
            </summary>
            <param name="k">restiction on label length</param>
            <param name="fa">the automaton to write</param>
            <param name="name">the name of the output file, if filename does not end with .dgml then .dgml is added as suffix</param>
        </member>
        <member name="M:Microsoft.Automata.DirectedGraphs.DgmlWriter.ShowGraph``1(System.Int32,Microsoft.Automata.IAutomaton{``0},System.String,System.Func{``0,System.String})">
            <summary>
            Write the automaton in dgml format in the current directory and open the file in a new process.
            </summary>
            <param name="k">restiction on label length</param>
            <param name="fa">the automaton to write</param>
            <param name="name">the name of the output file, if filename does not end with .dgml then .dgml is added as suffix</param>
            <param name="describeS">custom viewer for S, default is null, if null then ToString is used</param>
        </member>
        <member name="M:Microsoft.Automata.DirectedGraphs.DgmlWriter.SaveGraph``1(System.Int32,Microsoft.Automata.IAutomaton{``0},System.String,System.Func{``0,System.String})">
            <summary>
            Write the automaton in dgml format in the current directory.
            </summary>
            <param name="fa">the automaton to write</param>
            <param name="name">the name of the output file, if filename does not end with .dgml then .dgml is added as suffix</param>
        </member>
        <member name="M:Microsoft.Automata.DirectedGraphs.DgmlWriter.AutomatonToDgml``1(System.Int32,Microsoft.Automata.IAutomaton{``0},System.String,System.IO.TextWriter,System.Func{``0,System.String})">
            <summary>
            Write the automaton in dgml format.
            </summary>
            <param name="fa">the automaton to write</param>
            <param name="tw">text writer for the output</param>
        </member>
        <member name="M:Microsoft.Automata.DirectedGraphs.DgmlWriter.ShowSTb``1(System.Int32,Microsoft.Automata.ISTb{``0})">
            <summary>
            Write the automaton in dgml format in the current directory and open the file in a new process.
            </summary>
            <param name="fa">the automaton to write</param>
            <param name="name">the name of the output file, if filename does not end with .dgml then .dgml is added as suffix</param>
        </member>
        <member name="T:Microsoft.Automata.DirectedGraphs.DotWriter">
            <summary>
            Provides functionality for producing dot output.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.DirectedGraphs.DotWriter.RANKDIR">
            <summary>
            Used for saving automata as graphs in dot format.
            Provides the direction of the graph.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.DirectedGraphs.DotWriter.CharSetToDot(Microsoft.Automata.BDD,System.String,System.String,Microsoft.Automata.DirectedGraphs.DotWriter.RANKDIR,System.Int32)">
            <summary>
            Store the set as a BDD in dot format
            </summary>
            <param name="bdd"></param>
            <param name="bddName"></param>
            <param name="filename"></param>
            <param name="rankdir"></param>
            <param name="fontsize"></param>
        </member>
        <member name="M:Microsoft.Automata.DirectedGraphs.DotWriter.AutomatonToDot``1(System.Func{``0,System.String},Microsoft.Automata.IAutomaton{``0},System.String,System.String,Microsoft.Automata.DirectedGraphs.DotWriter.RANKDIR,System.Int32,System.Boolean)">
            <summary>
            Write the automaton in dot format.
            </summary>
            <param name="fa">the automaton to write</param>
            <param name="faName">the name of the automaton</param>
            <param name="filename">the name of the output file</param>
            <param name="rankdir">the main direction of the arrows</param>
            <param name="fontsize">the size of the font in labels</param>
            <param name="descr">function that describes the labels as strings</param>
        </member>
        <member name="M:Microsoft.Automata.DirectedGraphs.DotWriter.AutomatonToDot``1(System.Func{``0,System.String},Microsoft.Automata.IAutomaton{``0},System.String,System.IO.TextWriter,Microsoft.Automata.DirectedGraphs.DotWriter.RANKDIR,System.Int32,System.Boolean)">
            <summary>
            Write the FSA in dot format.
            </summary>
            <param name="fa">the FSA to write</param>
            <param name="faName">the name of the FSA</param>
            <param name="tw">text writer for the output</param>
            <param name="rankdir">the main direction of the arrows</param>
            <param name="fontsize">the size of the font in labels</param>
            <param name="descr">function that describes the labels as strings</param>
        </member>
        <member name="F:Microsoft.Automata.Generated.IgnoreCaseRelation.ignorecase">
            <summary>
            Serialized BDD for mapping characters to their case-ignoring equivalence classes.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.ASCII">
            <summary>
            Array of 30 UnicodeCategory ranges. Each entry is a pair of integers. 
            corresponding to the lower and upper bounds of the unicodes of the characters
            that have the given UnicodeCategory code (between 0 and 29).
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.ASCIIBdd">
            <summary>
            Compact BDD encodings of the categories.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.ASCIIWhitespace">
            <summary>
            Whitespace character ranges.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.ASCIIWordCharacter">
            <summary>
            Word character ranges.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.ASCIIWhitespaceBdd">
            <summary>
            Compact BDD encoding of the whitespace characters.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.ASCIIWordCharacterBdd">
            <summary>
            Compact BDD encoding of word characters
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.CP437Bdd">
            <summary>
            Compact BDD encodings of the categories.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.CP437WhitespaceBdd">
            <summary>
            Compact BDD encoding of the whitespace characters.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.CP437WordCharacterBdd">
            <summary>
            Compact BDD encoding of word characters
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.UnicodeBdd">
            <summary>
            Compact BDD encodings of the categories.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.UnicodeWhitespaceBdd">
            <summary>
            Compact BDD encoding of the whitespace characters.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Generated.UnicodeCategoryRanges.UnicodeWordCharacterBdd">
            <summary>
            Compact BDD encoding of word characters
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Grammars.ContextFreeGrammar">
            <summary>
            Symbolic Context Free Grammar
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Grammars.ContextFreeGrammar.BuiltinTerminalAlgebra">
            <summary>
            Returns the underlying builtin character set solver if it was used for parsing terminals, returns null othewise.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.RestrictToVariables(System.Collections.Generic.HashSet{Microsoft.Automata.Grammars.Nonterminal})">
            <summary>
            Restrict the grammar to the given variables.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.RemoveUselessSymbols">
            <summary>
            Removes useless symbols from the grammar.
            Assumes that the language is nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.GetUsefulNonterminals">
            <summary>
            Return all useful nonterminal symbols.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.GetUsefulNonterminals(System.Boolean)">
            <summary>
            Return all useful nonterminal symbols. If checkBackwardsOnly is true, assume that all symbols are reachable from the start symbol.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.RemoveUnitProductions">
            <summary>
            Removes all productions of the form A->B where A and B are variables.
            Removes also all the useless symbols after the unit production elimination.
            Assumes that the grammar has no epsilon productions. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.RemoveEpsilonsAndUselessSymbols">
            <summary>
            Removes epsilon productions and then removes useless symbols.
            Assumes that the grammar does not accept the empty string and that the language is nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.MkCNF(Microsoft.Automata.Grammars.ContextFreeGrammar)">
            <summary>
            Returns MkCNF(g, true)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.MkCNF(Microsoft.Automata.Grammars.ContextFreeGrammar,System.Boolean)">
            <summary>
            Produces the CNF (Chomsky Normal Form) for the grammar g.
            It first eliminates epsilons, useless symbols, and unit productions.
            If Assumes that there are no epsilons, useless symbols or unit productions
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.MkGNF(Microsoft.Automata.Grammars.ContextFreeGrammar,System.Boolean)">
            <summary>
            Produces the GNF (Greibach Normal Form) for the grammar g.
            If g is not already in GNF, first makes CNF.
            Implements a variation of the Koch-Blum algorithm. (STACS 97, pp. 47-54)
            </summary>
            <param name="g"></param>
            <param name="removeEpsilonsUselessSymbolsUnitsProductions"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.IsInGNF">
            <summary>
            Returns true if the grammar is in GNF (Greibach Normal Form)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.IsInCNF">
            <summary>
            Returns true if the grammar is in CNF (Chomsky Normal Form)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.MkEGNF(Microsoft.Automata.Grammars.ContextFreeGrammar)">
            <summary>
            Produces the EGNF (Extended Greibach Normal Form) for the grammar g. 
            The grammar g can be arbitrary. First removes epsilons and useless symbols from g.
            Implements a variation of the Blum-Koch algorithm. 
            (Inf. and Comp. vol.150, pp.112-118, 1999)
            </summary>
            <param name="g">the grammar to be normalized</param>
            <returns>Extended Greibach Normal Form of g</returns>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.MkEGNF(Microsoft.Automata.Grammars.ContextFreeGrammar,System.Boolean)">
            <summary>
            Produces the EGNF (Extended Greibach Normal Form) for the grammar g. 
            Implements a variation of the Blum-Koch algorithm. 
            (Inf. and Comp. vol.150, pp.112-118, 1999)
            </summary>
            <param name="g">the grammar to be normalized</param>
            <param name="removeEpsilonsAndUselessSymbols">if true, first removes epsilons and useless symbols, otherwise assumes that epsilons do not occur</param>
            <returns>Extended Greibach Normal Form of g</returns>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.Display(System.IO.TextWriter)">
            <summary>
            Writes the productions 'E -> alpha_1 | alpha_2 | ... | alpha_n' to tw 
            with the set of productions for each nonterminal E (variable) per line.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Grammars.ContextFreeGrammar.Description">
            <summary>
            Returns the productions 'E -> rhs_1 | rhs_2 | ... | rhs_n' 
            for each nonterminal E as a single string separated by newlines.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.ToString">
            <summary>
            Returns the value of Description
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.Overlaps``1(Microsoft.Automata.Automaton{``0},``0[]@)">
            <summary>
            Returns true if the language of the grammar intersects with the 
            language of the automaton, if true then a witness is produced
            in terms of a sequence of predicates over input characters.
            Assumes that the grammar is in GNF and terminals have type T.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.ToPDA``1">
            <summary>
            Convert the CFG to an equivalent PDA.
            The stack symbols are the grammar symbols of the grammar 
            and two extra symbols are added for start and end.
            It is assumed that the terminal labels of the grammar have type T.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.Parse``1(System.Func{System.String,Microsoft.Automata.Automaton{``0}},System.String)">
            <summary>
            Parse a CFG from the input string. Use the custom regex parser to parse terminals as regexes into automata.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.Parse(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Parse a CFG from the input string. Use the builting regex parser to parse terminals as regexes into automata.
            All terminal regexes are parsed in RegexOptions.Singleline mode so '.' means any character.
            Stores an instance of CharSetSolver in context.
            </summary>
            <param name="removeEpsilonsFromAutomata">if true then remove epsilons from the automata contructed from terminals</param>
            <param name="determinizeAutomata">if true then determinize the automata contructed from terminals (also removes epsilons)</param>
            <param name="minimizeAutomata">if true then minimize the automata contructed from terminals (also removes epsilons, if determinize is false then uses bisimulation based minimization)</param>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.IntersectsWith(System.String,System.String@,System.Boolean,System.Boolean)">
            <summary>
            Checks if the context free language of this grammar intersects with the regular language defined by the regex.
            If the languages intersect then outputs a witness and returns true, otherwise returns false and sets witness to null.
            Regex is parsed in RegexOptions.Singleline mode so '.' means any character.
            Anchors are not implicit, eg, regex 'ab+c' is the same as '.*ab+c.*.'
            Use explicit anchors, as in ^ab+c$, if anchors are intended.
            </summary>
            <param name="regex">given regex</param>
            <param name="determinizeAutomaton">if true then determinize the automaton constructed from the regex</param>
            <param name="minimizeAutomaton">if true then minimize the automaton constructed from the regex, if determinise is false then uses bisimulation to minimize</param>
        </member>
        <member name="M:Microsoft.Automata.Grammars.ContextFreeGrammar.IntersectsWith(System.String[],System.String@,System.Boolean,System.Boolean)">
            <summary>
            Checks if the context free language of this grammar intersects with all the regular languages defined by the regexes.
            If the languages intersect then outputs a witness and returns true, otherwise returns false and sets witness to null.
            Regexes are parsed in RegexOptions.Singleline mode so '.' means any character.
            Anchors are not implicit, eg, regex 'ab+c' is the same as '.*ab+c.*.'
            Use explicit anchors, as in ^ab+c$, if anchors are intended.
            </summary>
            <param name="regexes">given regexes to intersect with</param>
            <param name="determinizeAutomaton">if true then determinize the automaton constructed from the regex</param>
            <param name="minimizeAutomaton">if true then minimize the automaton constructed from the regex, if determinise is false then uses bisimulation to minimize</param>
        </member>
        <member name="F:Microsoft.Automata.Grammars.Nonterminal.StartStackSymbol">
            <summary>
            Nonterminal "^"
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Grammars.Nonterminal.EndStackSymbol">
            <summary>
            Nonterminal "$"
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.Nonterminal.MkNonterminalForStateId(System.Int32)">
            <summary>
            Appends ReservedNonterminalStart + "q" in front of state id represented in decimal.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.Nonterminal.MkNonterminalForRegex(System.Int32)">
            <summary>
            Appends ReservedNonterminalStart + "r" in front of id represented in decimal.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.Nonterminal.MkNonterminalForId(System.Int32)">
            <summary>
            Appends ReservedNonterminalStart in front of id represented in decimal.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.Nonterminal.MkNonterminalForZ3Expr(System.String)">
            <summary>
            Uses the name as is
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.Nonterminal.MkNonterminalForAutomatonState(System.String,System.Int32)">
            <summary>
            Produces the nonterminal regexId + '_' + stateId
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.Nonterminal.CreateByParser(System.String)">
            <summary>
            Creates the nonterminal with the name as is during parsing.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Grammars.Production.IsEpsilon">
            <summary>
            Returns true if Rhs is empty
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Grammars.Production.First">
            <summary>
            Returns the First symbol in the Rhs.
            Assumes that Rhs is nonempty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Grammars.Production.FirstIsTerminal">
            <summary>
            Returns true if the first symbol is a terminal
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Grammars.Production.Rest">
            <summary>
            Returns the symbols in the Rhs except the first one.
            Assumes that Rhs is nonempty.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Grammars.Terminal`1">
            <summary>
            terminal symbol
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Grammars.Terminal`1.term">
            <summary>
            the term
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.Terminal`1.#ctor(`0)">
            <summary>
            constructs a terminal
            </summary>
            <param name="term">given term</param>
            <param name="name">given name</param>
        </member>
        <member name="P:Microsoft.Automata.Grammars.Terminal`1.Name">
            <summary>
            name of the terminal
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Grammars.Terminal`1.ToString">
            <summary></summary>
        </member>
        <member name="T:Microsoft.Automata.IAcceptor`3">
            <summary>
            Methods for asserting the axiomatic theory and accessing the language acceptor of an SFA or the transduction acceptor of an ST.
            </summary>
            <typeparam name="FUNC">function declarations, each function declaration has domain and range sorts</typeparam>
            <typeparam name="TERM">terms, each term has a fixed sort</typeparam>
            <typeparam name="SORT">sorts correspond to different subuniverses of elements</typeparam>
        </member>
        <member name="P:Microsoft.Automata.IAcceptor`3.Solver">
            <summary>
            The given SMT solver. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IAcceptor`3.AssertTheory">
            <summary>
            Assert the theory as an auxiliary background theory to the given SMT solver
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IAcceptor`3.Acceptor">
            <summary>
            Relation symbol of the language or transduction relation. 
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IAutomaton`1">
            <summary>
            For accessing the key components of an automaton.
            </summary>
            <typeparam name="L">type of labels in moves</typeparam>
        </member>
        <member name="M:Microsoft.Automata.IAutomaton`1.GetMoves">
            <summary>
            Enumerates all moves of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IAutomaton`1.GetStates">
            <summary>
            Enumerates all states of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IAutomaton`1.DescribeState(System.Int32)">
            <summary>
            Provides a description of the state for visualization purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IAutomaton`1.DescribeLabel(`0)">
            <summary>
            Provides a description of the label for visualization purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IAutomaton`1.DescribeStartLabel">
            <summary>
            Provides a description of the label for visualization purposes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.Automata.IMinimalAutomaton`1" -->
        <member name="P:Microsoft.Automata.IMinimalAutomaton`1.InitialState">
            <summary>
            The initial state of the automaton.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IMinimalAutomaton`1.Algebra">
            <summary>
            Gets the algebra of the labels.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IMinimalAutomaton`1.IsFinalState(System.Int32)">
            <summary>
            Returns true iff the state is a final state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IMinimalAutomaton`1.GetMovesFrom(System.Int32)">
            <summary>
            Enumerates all moves of the automaton from the given start state.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IBooleanAlgebraPositive`1">
            <summary>
            Boolean Algebra Positive operations.
            Provides elements for true and false.
            Provides operations for conjunction, disjunction, and satisfiability checking of predicates.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebraPositive`1.MkAnd(`0,`0)">
            <summary>
            Make a conjunction of predicate1 and predicate2.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebraPositive`1.MkOr(`0,`0)">
            <summary>
            Make a disjunction of predicate1 and predicate2. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebraPositive`1.IsSatisfiable(`0)">
            <summary>
            Returns true iff the predicate is satisfiable.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IBooleanAlgebraPositive`1.True">
            <summary>
            Top element of the Boolean algebra, corresponds to the value true.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IBooleanAlgebraPositive`1.False">
            <summary>
            Bottom element of the Boolean algebra, corresponds to the value false.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IBooleanAlgebra`1">
            <summary>
            Generic Boolean Algebra solver.
            Provides operations for conjunction, disjunction, and negation.
            Allows to decide if a predicate is satisfiable and if two predicates are equivalent.
            </summary>
            <typeparam name="S">predicates</typeparam>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.MkOr(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Make a disjunction of all the predicates in the enumeration. 
            Must return False if the enumeration is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.MkAnd(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Make a conjunction of all the predicates in the enumeration. 
            Returns True if the enumeration is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.MkAnd(`0[])">
            <summary>
            Make a conjunction of all the predicates. 
            Returns True if the enumeration is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.MkNot(`0)">
            <summary>
            Negate the predicate.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.MkDiff(`0,`0)">
            <summary>
            Compute the predicate and(predicate1,not(predicate2))
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.AreEquivalent(`0,`0)">
            <summary>
            Returns true iff predicate1 is equivalent to predicate2.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.MkSymmetricDifference(`0,`0)">
            <summary>
            Returns a predicate that is equivalent to (p1&amp;!p2)|(p2&amp;!p1).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.CheckImplication(`0,`0)">
            <summary>
            Returns true iff lhs implies rhs.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IBooleanAlgebra`1.IsExtensional">
            <summary>
            True iff any two equivalent predicates are identical.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.Simplify(`0)">
            <summary>
            Simplifies the predicate. 
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IBooleanAlgebra`1.IsAtomic">
            <summary>
            Returns true iff the algebra is atomic:
            each satisfiable predicate is implied by an atomic predicate. 
            A predicate p is atomic means: p is satisfiable and if q =&gt; p then q &lt;=&gt; p.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.GetAtom(`0)">
            <summary>
            If the algebra is atomic and psi is satisfiable 
            then returns an atomic predicate that implies psi.
            Returns False if psi is unsatisfiable.
            Throws AutomataException if the algebra is not atomic.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.EvaluateAtom(`0,`0)">
            <summary>
            The predicate atom must represent a singleton set {v} for some value v.
            Returns true iff v is accepted by psi.
            </summary>
            <param name="atom">predicate denoting a singleton set</param>
            <param name="psi">some predicate</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.IBooleanAlgebra`1.GenerateMinterms(`0[])">
            <summary>
            Given an array of constraints {c_1, c_2, ..., c_n} where n&gt;=0.
            Enumerate all satisfiable Boolean combinations Tuple({b_1, b_2, ..., b_n}, c)
            where c is satisfisable and equivalent to c'_1 &amp; c'_2 &amp; ... &amp; c'_n, 
            where c'_i = c_i if b_i = true and c'_i is Not(c_i) otherwise.
            If n=0 return Tuple({},True)
            </summary>
            <param name="constraints">array of constraints</param>
            <returns>Booolean combinations that are satisfiable</returns>
        </member>
        <member name="T:Microsoft.Automata.ICharAlgebra`1">
            <summary>
            Extends IBooleanAlgebra with character predicate solving and predicate pretty printing.
            </summary>
            <typeparam name="PRED">predicates</typeparam>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.MkRangeConstraint(System.Char,System.Char,System.Boolean)">
            <summary>
            Make a constraint describing the set of all characters between a (inclusive) and b (inclusive). 
            Add both uppercase and lowercase elelements if caseInsensitive is true.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.MkCharConstraint(System.Char,System.Boolean)">
            <summary>
            Make a constraint describing a singleton set containing the character c, or
            a set containing also the upper and lowercase versions of c if caseInsensitive is true.
            </summary>
            <param name="caseInsensitive">if true include both the uppercase and the lowercase versions of the given character</param>
            <param name="c">the given character</param>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.MkRangesConstraint(System.Boolean,System.Collections.Generic.IEnumerable{System.Char[]})">
            <summary>
            Make the disjunction of MkRangeConstraint(caseInsensitive, a, b) for all [a,b] in ranges.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.ConvertFromCharSet(Microsoft.Automata.BDD)">
            <summary>
            Make a term that encodes the given character set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.ComputeDomainSize(`0)">
            <summary>
            Compute the number of elements in the set
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.GenerateAllCharacters(`0)">
            <summary>
            Enumerate all characters in the set
            </summary>
            <param name="set">given set</param>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.ConvertToCharSet(Microsoft.Automata.IBDDAlgebra,`0)">
            <summary>
            Convert a predicate into a set of characters.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICharAlgebra`1.CharSetProvider">
            <summary>
            Gets the underlying character set solver.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.MkCharPredicate(System.String,`0)">
            <summary>
            If named definitions are possible, 
            makes a named definition of pred, as a unary relation symbol, 
            such that, for all x, name(x) holds iff body(x) holds. Returns the 
            atom name(x) that is equivalent to pred(x).
            If named definitions are not supported, returns pred.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.MkSet(System.UInt32)">
            <summary>
            Makes a singleton set consisting of e.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.Choose(`0)">
            <summary>
            Chooses a random member of a nonempty set s.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.ChooseUniformly(`0)">
            <summary>
            Chooses a random character uniformly at random from a nonempty set s.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.GetPartition">
            <summary>
            Returns a partition of the full domain.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.SerializePredicate(`0)">
            <summary>
            Serialize the predicate using characters in [0-9a-f\-\.]
            </summary>
            <param name="s">given predicate</param>
        </member>
        <member name="M:Microsoft.Automata.ICharAlgebra`1.DeserializePredicate(System.String)">
            <summary>
            Deserialize the predicate from a string constructed with Serialize
            </summary>
            <param name="s">given serialized predicate</param>
        </member>
        <member name="T:Microsoft.Automata.IContext`3">
            <summary>
            Context interface.
            </summary>
            <typeparam name="FUNC">function declarations, each function declaration has domain and range sorts</typeparam>
            <typeparam name="TERM">terms, each term has a fixed sort</typeparam>
            <typeparam name="SORT">sorts correspond to different subuniverses of elements</typeparam>
        </member>
        <member name="P:Microsoft.Automata.IContext`3.BoolSort">
            <summary>
            Sort of Boolean values
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IContext`3.IntSort">
            <summary>
            Sort of integers
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IContext`3.UnitSort">
            <summary>
            Sort of a fixed singleton domain containing the element UnitConst.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IContext`3.UnitConst">
            <summary>
            The single fixed element of sort UnitSort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkBitVecSort(System.UInt32)">
            <summary>
            Sort of bit-vectors.
            </summary>
            <param name="bits">nr of bits in the bit-vectors</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetSort(`1)">
            <summary>
            Get the sort of a given term.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkVar(System.UInt32,`2)">
            <summary>
            Make a variable with the given index and sort
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.IsVar(`1)">
            <summary>
            Returns true if the given term is a variable.
            </summary>
            <param name="v">given term</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetVarIndex(`1)">
            <summary>
            Gets the index of the variable v.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkConst(System.String,`2)">
            <summary>
            Declares an uninterpreted constant with the given name and sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkFreshConst(System.String,`2)">
            <summary>
            Make a fresh uninterpreted constant (nullary function symbol) with a given prefix of the name and sort.
            </summary>
            <param name="prefix">prefix of the name</param>
            <param name="sort">sort of the constant</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetVars(`1)">
            <summary>
            Enumerates all variables in term t without repetitions, 
            assumes that t is quantifier-free.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkNumeral(System.Int32,`2)">
            <summary>
            Make a concrete term corresponding to n.
            The sort must be integer or bitvector.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkNumeral(System.UInt32,`2)">
            <summary>
            Make a concrete term corresponding to n.
            The sort must be integer or bitvector.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetNumeralUInt(`1)">
            <summary>
            Get the unsigned integer value represented by the concrete term t.
            </summary>
            <param name="t">must be a concrete numeric term</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetNumeralInt(`1)">
            <summary>
            Get the signed integer value represented by the concrete term t.
            </summary>
            <param name="t">must be a concrete numeric term</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.ConvertBitVector(`1,`2)">
            <summary>
            Convert bv to the given sort (by appending 0's at the beginning when the given sort has more bits).
            The sort of bv and s must be bit-vector sorts.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkBvExtract(System.UInt32,System.UInt32,`1)">
            <summary>
            Extract the sub-bitvector from bv.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IContext`3.RegexConverter">
            <summary>
            Gets the .NET regex converter.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkBvAnd(`1,`1)">
            <summary>
            Bitwise and of bitvectors
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkBvOr(`1,`1)">
            <summary>
            Bitwise or of bitvectors
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkBvShiftRight(System.UInt32,`1)">
            <summary>
            Shift right
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkBvShiftLeft(System.UInt32,`1)">
            <summary>
            Shift left.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetDomain(`0)">
            <summary>
            Get the argument sorts of a function symbol.
            </summary>
            <param name="f">function symbol</param>
            <returns>array of length n of argment sorts where n is the arity of f</returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetRange(`0)">
            <summary>
            Get the range sort of a function symbol.
            </summary>
            <param name="f">function symbol</param>
            <returns>result or range sort of f</returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkFreshFuncDecl(System.String,`2[],`2)">
            <summary>
            Declare a fresh uninterpreted function symbol with given prefix f of the name, arity domSorts.Length, and of given domain and range sorts.
            </summary>
            <param name="f">prefix of the name</param>
            <param name="domSorts">domain (argument) sorts</param>
            <param name="ranSort">range (value) sort</param>
            <returns>uninterpreted function symbol from domSorts to ranSort</returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkFuncDecl(System.String,`2[],`2)">
            <summary>
            Make uninterpreted function declaration f: domSorts -> ranSort
            </summary>
            <param name="f">prefix of the name</param>
            <param name="domSorts">domain (argument) sorts</param>
            <param name="ranSort">range (value) sort</param>
            <returns>uninterpreted function symbol from domSorts to ranSort</returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkFuncDecl(System.String,`2,`2)">
            <summary>
            Make uninterpreted function declaration f: domain -> range
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkApp(`0,`1[])">
            <summary>
            Make a term with function symbol f and arguments args
            </summary>
            <param name="f">function symbol</param>
            <param name="args">arguments whose sorts must match the corresponding domain sort of f</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetAppArgs(`1)">
            <summary>
            Gets the immediate subterms of a term. Returns the empty array if t is a constant.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetDeclName(`0)">
            <summary>
            Gets the name of the function declaration.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetDeclShortName(`0)">
            <summary>
            Gets the name of the function declaration by omitting the parameter suffix if there is one.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetDeclParameters(`0)">
            <summary>
            Gets the function declaration parameters if the name has a parameter suffix [p_1:p_2:...:p_k].
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkListSort(`2)">
            <summary>
            Make a list sort with the given element sort
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.IsListSort(`2)">
            <summary>
            Returns true if the given sort is a listsort
            </summary>
            <param name="sort">given sort</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetNil(`2)">
            <summary>
            Get the empty list of the given list sort.
            </summary>
            <param name="listSort">must be a list sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetElemSort(`2)">
            <summary>
            Gets the element sort of a list sort.
            </summary>
            <param name="listSort">must be a list sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkList(`1[])">
            <summary>
            Makes a list of the terms. 
            Assumes that all terms in ts have the same sort and that ts is nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkListFromString(System.String,`2)">
            <summary>
            Makes a list with the given numeric element sort. 
            Each character of the string is considered as its numeric code and converted 
            into corresponding numeric term.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkListWithRest(`1[],`1)">
            <summary>
            Makes a list of the terms in elems (may be null or empty), 
            with rest as the remaining list.
            Assumes that all terms in elems have the same sort 
            and that rest is a term of the corresponding list sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkListCons(`1,`1)">
            <summary>
            Makes a list cons(first,rest). The element sort of rest must equal to the sort of first.
            </summary>
            <param name="first">first element</param>
            <param name="rest">rest of the list</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkFirstOfList(`1)">
            <summary>
            Make a term that accesses the first element of the list.
            </summary>
            <param name="list">must be a term of List sort</param>
            <returns>a term of element sort of the list representing the first element of the list</returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkIsCons(`1)">
            <summary>
            Make a term that test that the list is nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkIsNil(`1)">
            <summary>
            Make a term that test that the list is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkRestOfList(`1)">
            <summary>
            Make a term that accesses the rest of the list.
            </summary>
            <param name="list">must be a term of List sort</param>
            <returns>a term of the same list sort representing the rest of the list</returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkTupleSort(`2[])">
            <summary>
            Makes a tuple sort with a default sort name of the given element sorts.
            </summary>
            <param name="elemSorts">nonempty array of element sorts</param>
            <returns>tuple sort of the given element sorts</returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.IsTupleSort(`2)">
            <summary>
            Returns true iff the sort is a tuple sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetTupleLength(`2)">
            <summary>
            Get the number of elements in a tuple of the given tuple sort.
            </summary>
            <param name="tupleSort">must be a tuple sort</param>
            <returns>a positive number</returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetTupleElementSort(`2,System.Int32)">
            <summary>
            Get the sort of the p'th element of the tuple sort.
            The index p must be between 0 and GetTupleLength(tupleSort)-1.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkOptionSort(`2)">
            <summary>
            Makes an option sort with the given element sort
            </summary>
            <param name="s">element sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkNone(`2)">
            <summary>
            Gets the None value of the given option sort.
            </summary>
            <param name="s">option sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetOptionValueSort(`2)">
            <summary>
            Gets the value sort of an option sort.
            </summary>
            <param name="s">option sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkSome(`1)">
            <summary>
            Lifts the term t to Some(t) of corresponding option sort.
            </summary>
            <param name="t">given term</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkIsSome(`1)">
            <summary>
            Makes a predicate that tests that t is not None.
            </summary>
            <param name="t">term of option sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkIsNone(`1)">
            <summary>
            Makes a predicate that tests that t is None.
            </summary>
            <param name="t">term of option sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkGetSomeValue(`1)">
            <summary>
            Makes a term that returns v from Some(v).
            </summary>
            <param name="t">term of option sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.IsOption(`2)">
            <summary>
            Returns true if the given sort is an option sort
            </summary>
            <param name="s">given sort</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharGe(`1,`1)">
            <summary>
            Character term x is lexicographically greater than or equal to character term y
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharGt(`1,`1)">
            <summary>
            Character term x is lexicographically strictly greater than character term y
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharLe(`1,`1)">
            <summary>
            Character term x is lexicographically smaller than or equal to character term y
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharLt(`1,`1)">
            <summary>
            Character term x is lexicographically strictly smaller than character term y
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharLSHB(`1)">
            <summary>
            Get the Least Significant Half-Byte (LSHB) from the character.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharAdd(`1,`1)">
            <summary>
            Addition
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.GetCharValue(`1)">
            <summary>
            Extract the character value from a ground charater term t.
            </summary>
            <param name="t">must be a concrete numeric term</param>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharExpr(System.Char)">
            <summary>
            Make character term from the character c
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharVar(System.UInt32)">
            <summary>
            Make character variable with identifier id
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharRem(`1,`1)">
            <summary>
            Remainder
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharDiv(`1,`1)">
            <summary>
            Divison of x by y
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharSub(`1,`1)">
            <summary>
            Subtraction x - y
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContext`3.MkCharMul(`1,`1)">
            <summary>
            Mutiplication x * y
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IContext`3.CharSort">
            <summary>
            Gets the character sort corresponding to the current character encoding.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IContextCore`1">
            <summary>
            Provides core context operations. 
            Operations that do not depend on function symbol or sort types.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.MkTuple(`0[])">
            <summary>
            Makes a tuple with a default constructor name of the terms in ts, ts must me nonempty.
            </summary>
            <param name="ts">nonempty array of terms</param>
            <returns>tuple of the terms in ts</returns>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.MkProj(System.Int32,`0)">
            <summary>
            Make the term that projects the p'th element from tuple z
            </summary>
            <param name="p">id of the element to be projected, must be between 0 and arity(tuple)-1</param>
            <param name="z">the given tuple term</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.MkIte(`0,`0,`0)">
            <summary>
            Make the if-then-else term Ite(cond,t,f) that equals t, if cond is true; equals f, otherwise, where t and f must have the same sort and cond must have Boolean sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.MkInt(System.Int32)">
            <summary>
            Make an integer term whose integer value is n.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.MkFreshConst(System.String,`0)">
            <summary>
            Make a fresh constant of the same sort ast the sort of t.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.IsGround(`0)">
            <summary>
            Returns true iff t is a ground term (contains no free variables).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.MkEq(`0,`0)">
            <summary>
            Make the equality constraint t1 = t2, where t1 and t2 must have the same sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.MkNeq(`0,`0)">
            <summary>
            Make the disequality constraint t1 != t2, where t1 and t2 must have the same sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.ApplySubstitution(`0,`0,`0)">
            <summary>
            Replace all occurrences of key in t by val, where key and val must have the same sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.ApplySubstitution(`0,`0,`0,`0,`0)">
            <summary>
            Simultaneously replace all occurrences of key_i in t by val_i for i=1,2, where key_i and val_i must have the same sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.ApplySubstitution(`0,System.Collections.Generic.IDictionary{`0,`0})">
            <summary>
            Simultaneously replace all occurrences of key in t by val for all (key,val) in the dictionary, where key and val must have the same sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.ToNNF(`0)">
            <summary>
            Converts all the Boolean subterms in t to an equivalent predicates in Negation Normal Form.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IContextCore`1.MkAxiom(`0,`0,`0[])">
            <summary>
            Makes the axiom 'Forall vars (lhs[vars] = rhs[vars])'.
            Assumes that lhs and rhs have the same sort.
            Assumes that all variables in rhs occur in vars.
            Assumes that the function symbol of lhs is an uninterpreted function symbol.
            </summary>
            <param name="lhs">term whose function symbol is uninterpreted</param>
            <param name="rhs">term that defines the meaning of lhs</param>
            <param name="vars">a sequence of distinct variables</param>
        </member>
        <member name="T:Microsoft.Automata.ICountingSet">
            <summary>
            A bounded set on integers that supports incrementing all elements adding 0 and 1.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICountingSet.UpperBound">
            <summary>
            What the maximum value in the set is allowed to be.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICountingSet.IsEmpty">
            <summary>
            True iff the set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICountingSet.IsSingleton">
            <summary>
            True iff the set is a singleton set.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICountingSet.Min">
            <summary>
            Gets the minimum value in the set. Set must be nonempty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICountingSet.Max">
            <summary>
            Gets the maximum value in the set. Set must be nonempty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICountingSet.Set0">
            <summary>
            Set the set to the value [0].
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICountingSet.Set1">
            <summary>
            Set the set to the value [1].
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICountingSet.Incr">
            <summary>
            Increment all values in the set.
            If Max becomes greater than UpperBound then remove it.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICountingSet.Push0">
            <summary>
            Push 0 into the set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICountingSet.Clear(Microsoft.Automata.ICounter)">
            <summary>
            Empty the set.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICountingSet.IncrPush0">
            <summary>
            Increment all values in the set and push 0 into the set.
            If Max becomes greater than UpperBound then remove it.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICountingSet.IncrPush1">
            <summary>
            Increment all values in the set and push 1 into the set.
            If Max becomes greater than UpperBound then remove it.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ICountingSet.IncrPush01">
            <summary>
            Increment all values in the set and push 0 and 1 into the set.
            If Max becomes greater than UpperBound then remove it.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IDeterministicFiniteTransducer">
            <summary>
            Deterministic finite state transducer.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IDeterministicFiniteTransducer.Q">
            <summary>
            All states.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IDeterministicFiniteTransducer.q0">
            <summary>
            Initial state.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IDeterministicFiniteTransducer.F">
            <summary>
            All final states.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IDeterministicFiniteTransducer.Sigma">
            <summary>
            Alphabet.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IDeterministicFiniteTransducer.Delta(System.Int32,System.Int32)">
            <summary>
            Transition function. Assumed to be a total function.
            </summary>
            <param name="state">source state</param>
            <param name="c">input character (negative value means end of string)</param>
            <returns>target state</returns>
        </member>
        <member name="M:Microsoft.Automata.IDeterministicFiniteTransducer.Psi(System.Int32,System.Int32)">
            <summary>
            Output function. Assumed to be a total function.
            </summary>
            <param name="state">source state</param>
            <param name="c">input character (negative value means end of string)</param>
            <returns>output sequence</returns>
        </member>
        <member name="T:Microsoft.Automata.IMatcher">
            <summary>
            Provides IsMatch and Matches methods and extends ISerializable.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IMatcher.IsMatch(System.String,System.Int32,System.Int32)">
            <summary>
            Returns true iff the input string matches. 
            <param name="input">given iput string</param>
            <param name="startat">start position in the input, default is 0</param>
            <param name="endat">end position in the input, -1 means that the value is unspecified and taken to be input.Length-1</param>
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IMatcher.Matches(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns all matches as pairs (startindex, length) in the input string.
            </summary>
            <param name="input">given iput string</param>
            <param name="limit">as soon as this many matches have been found the search terminates, 0 or negative value means that there is no bound, default is 0</param>
            <param name="startat">start position in the input, default is 0</param>
            <param name="endat">end position in the input, -1 means that the value is unspecified and taken to be input.Length-1</param>
        </member>
        <member name="M:Microsoft.Automata.IMatcher.GenerateRandomMatch(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generate a random string that is a complete match.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IMatcher.Serialize(System.IO.Stream,System.Runtime.Serialization.IFormatter)">
            <summary>
            Serialize this symbolic regex matcher to the given stream.
            If formatter is null then an instance of 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter is used.
            </summary>
            <param name="stream">stream where the serialization is stored</param>
            <param name="formatter">given formatter</param>
        </member>
        <member name="M:Microsoft.Automata.IMatcher.Serialize(System.String,System.Runtime.Serialization.IFormatter)">
            <summary>
            Serialize this symbolic regex matcher to the given file.
            If formatter is null then an instance of 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter is used.
            </summary>
            <param name="file">file where the serialization is stored</param>
            <param name="formatter">given formatter</param>
        </member>
        <member name="T:Microsoft.Automata.IFiniteAutomaton">
            <summary>
            Represents a compiled finite state automaton interface. Initial state is 0.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IFiniteAutomaton.IsFinalState(System.Int32)">
            <summary>
            Returns true iff q is a final state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IFiniteAutomaton.IsSinkState(System.Int32)">
            <summary>
            Returns true iff q loops for all characters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IFiniteAutomaton.Transition(System.Int32,System.Char[])">
            <summary>
            Returns the target state reached after reading the input characters from the source state q.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IFiniteAutomaton.IsMatch(System.String)">
            <summary>
            Returns true iff the automaton accepts the input
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IDeterministicFiniteAutomaton">
            <summary>
            Extends the IFiniteAutomaton interface, exposes the transition function
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IDeterministicFiniteAutomaton.Delta">
            <summary>
            The transition function. 
            The set of states is {0,...,Delta.Length-1}.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IDeterministicFiniteAutomaton.GenerateMatches(System.String,System.Tuple{System.Int32,System.Int32}[])">
            <summary>
            Returns the number of matches, and fills in the array with those matches (startindex, length) 
            </summary>
        </member>
        <member name="T:Microsoft.Automata.INameProvider">
            <summary>
            Allows to get and set a name as a string.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.INameProvider.Name">
            <summary>
            Gets and sets a name.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IPrettyPrinter`1">
            <summary>
            Pretty printer for a given type.
            </summary>
            <typeparam name="T">element type</typeparam>
        </member>
        <member name="M:Microsoft.Automata.IPrettyPrinter`1.PrettyPrint(`0)">
            <summary>
            Returns a string representation of the element t
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IPrettyPrinter`1.PrettyPrint(`0,System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the element t, uses varLookup for custom variable name lookup.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IPrettyPrinter`1.PrettyPrintCS(`0,System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the element t, uses varLookup for custom variable name lookup.
            Uses the form (cond ? t : f) instead of ite(cond,t,f) for printing ite-terms.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IRegexConverter`1">
            <summary>
            Provides functionality to convert regex patterns to corresponding symbolic finite automata
            and symbolic regexes.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IRegexConverter`1.Convert(System.String)">
            <summary>
            Converts a regex pattern into an eqivalent symbolic automaton.
            Same as Convert(regex, RegexOptions.None).
            </summary>
            <param name="regex">the given regex pattern</param>
        </member>
        <member name="M:Microsoft.Automata.IRegexConverter`1.Convert(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Converts a regex pattern into an equivalent symbolic automaton
            </summary>
            <param name="regex">the given regex pattern</param>
            <param name="options">regular expression options for the pattern</param>
        </member>
        <member name="M:Microsoft.Automata.IRegexConverter`1.ConvertString(System.String)">
            <summary>
            Converts a string s into an automaton that accepts s and no other strings.
            </summary>
            <param name="s">given input strings</param>
        </member>
        <member name="T:Microsoft.Automata.ISolver`1">
            <summary>
            Solver interface. Created from IContext.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ISolver`1.Push">
            <summary>
            Push a new logical context.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ISolver`1.Pop">
            <summary>
            Pop the current logical context.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ISolver`1.Assertions">
            <summary>
            All asserted constraints.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ISolver`1.NumAssertions">
            <summary>
            Number of asserted constraints.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ISolver`1.Check">
            <summary>
            Check if the asserted constraints are satisfiable. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ISolver`1.Assert(`0)">
            <summary>
            Assert the formula in the solver.
            </summary>
            <param name="constraint"></param>
        </member>
        <member name="M:Microsoft.Automata.ISolver`1.IsSatisfiable(`0)">
            <summary>
            Check satisfiability of the constraint in the solver without changing the assertions.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ISolver`1.GetModel(`0,`0[])">
            <summary>
            If the assertion is satisfiable, returns an interpretation of the terms to be evaluated.
            The returned dictionary is empty if no terms are listed for evaluation.
            The assertion may not contain free variables.
            Returns null iff the assertion is unsatisfiable.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ISolver`1.FindAllMembers(`0)">
            <summary>
            Find all solutions of an open formula containing exactly one free variable.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ISolver`1.FindOneMember(`0)">
            <summary>
            Find one solution of an open formula containing exactly one free variable.
            </summary>
            <param name="openFormula">formula containing exactly one free variable</param>
            <returns>a value satisfying the formula or null if no value was found</returns>
        </member>
        <member name="T:Microsoft.Automata.ITransducer`1">
            <summary>
            Extends the IAutomaton interface with transducer specific methods.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ITransducer`1.IsFinalRule(`0)">
            <summary>
            Returns true iff the label is a final rule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ITransducer`1.DescribeGuard(`0)">
            <summary>
            Provides a description of the guard of the rule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ITransducer`1.IsGuardTrue(`0)">
            <summary>
            Returns true iff the guard of the rule is unconditionally true.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ITransducer`1.GetYieldsLength(`0)">
            <summary>
            Returns the nr of yields of the rule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ITransducer`1.DescribeYields(`0)">
            <summary>
            Provides a description of the yields of the rule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ITransducer`1.DescribeUpdate(`0)">
            <summary>
            Provides a description of the update of the rule.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IValue`1">
            <summary>
            Represents a concrete value
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IValue`1.Value">
            <summary> 
            A ground term.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IValue`1.TryGetNumeralValue(System.Int32@)">
            <summary>
            Returns true if Value represents a numeral and outputs the numeral in n.
            Returns false otherwise and sets n to 0.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IValue`1.GetStringValue(System.Boolean)">
            <summary>
            If Value is a list whose elements are numerals return 
            the corresponding string, otherwise return null.
            </summary>
            <param name="unicode">if true, extract numeric values above 65536 to proper UTF-16 code points, otherwise truncate them to single characters ignoring all bits in binary representation in positions 17 and higher</param>
        </member>
        <member name="P:Microsoft.Automata.IValue`1.StringValue">
            <summary>
            If Value is a list whose elements are numerals gets 
            GetStringValue(false), otherwise return null.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IValue`1.GetList">
            <summary>
            If the value is a list get the corresponding elements.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.AutomataAlgebra`1">
            <summary>
            Boolean algebra whose predicates are Automata over S.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.#ctor(Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Construct the automata algebra for the character solver for the predicate automata.
            </summary>
            <param name="solver"></param>
        </member>
        <member name="P:Microsoft.Automata.AutomataAlgebra`1.True">
            <summary>
            Automaton that accepts everything.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.AutomataAlgebra`1.False">
            <summary>
            Automaton that accepts nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.MkOr(System.Collections.Generic.IEnumerable{Microsoft.Automata.Automaton{`0}})">
            <summary>
            Make a union automaton of the given automata
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.MkAnd(System.Collections.Generic.IEnumerable{Microsoft.Automata.Automaton{`0}})">
            <summary>
            Make an product automaton of the given automata
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.MkAnd(Microsoft.Automata.Automaton{`0}[])">
            <summary>
            Make an product automaton of the given automata
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.MkNot(Microsoft.Automata.Automaton{`0})">
            <summary>
            Complement the automaton
            </summary>
            <param name="aut"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.AreEquivalent(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            Return true iff the two automata are equivalent
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.MkOr(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            Make a union automaton of the two automata
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.MkAnd(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            Make a product automaton of the two automata
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.IsSatisfiable(Microsoft.Automata.Automaton{`0})">
            <summary>
            Returns true if the automaton accepts at least one input
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.GenerateMinterms(Microsoft.Automata.Automaton{`0}[])">
            <summary>
            Generate minterms for the constraints
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.Simplify(Microsoft.Automata.Automaton{`0})">
            <summary>
            Minimizes the automaton
            </summary>
        </member>
        <member name="P:Microsoft.Automata.AutomataAlgebra`1.IsExtensional">
            <summary>
            Returns false
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.MkSymmetricDifference(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            Makes the su=ymmetric difference
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.CheckImplication(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            Returns true if L(lhs) is a subset of L(rhs)
            </summary>
        </member>
        <member name="P:Microsoft.Automata.AutomataAlgebra`1.IsAtomic">
            <summary>
            Retuns true iff the underlying character solver is atomic.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.GetAtom(Microsoft.Automata.Automaton{`0})">
            <summary>
            Gets the atom of a predicate.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.EvaluateAtom(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            not implemented
            </summary>
        </member>
        <member name="M:Microsoft.Automata.AutomataAlgebra`1.MkDiff(Microsoft.Automata.Automaton{`0},Microsoft.Automata.Automaton{`0})">
            <summary>
            Makes an automaton that accepts L(predicate1) - L(predicate2)
            </summary>
        </member>
        <member name="P:Microsoft.Automata.CharRangeSolver.Encoding">
            <summary>
            The character encoding used by the solver
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ComparablePair`2">
            <summary>
            Pair of comparable elements
            </summary>
        </member>
        <member name="M:Microsoft.Automata.EditDistance.GetClosestElement(System.String,Microsoft.Automata.Automaton{Microsoft.Automata.BDD},Microsoft.Automata.CharSetSolver,System.Int32@,System.Boolean)">
            <summary>
            Based on paper
            Order-n correction for regular langauges, http://dl.acm.org/citation.cfm?id=360995
            </summary>
            <param name="str">input string</param>
            <param name="automaton">dfa for which you want to compute the distance</param>
            <param name="solver">character solver</param>
            <param name="distance">outputs the distance</param>
            <returns>the closest string to str in automaton</returns>
        </member>
        <member name="M:Microsoft.Automata.EditDistance.GetClosestElement(System.String,Microsoft.Automata.Automaton{Microsoft.Automata.BDD},Microsoft.Automata.CharSetSolver,System.Int32,System.Int32@,System.Boolean)">
            <summary>
            Based on paper
            Order-n correction for regular langauges, http://dl.acm.org/citation.cfm?id=360995
            </summary>
            <param name="str">input string</param>
            <param name="automaton">dfa for which you want to compute the distance</param>
            <param name="solver">character solver</param>
            <param name="bound">depth of search for max string insertion</param>
            <param name="distance">outputs the distance</param>
            <returns>the closest string to str in automaton</returns>
        </member>
        <member name="M:Microsoft.Automata.EditDistance.GetEditDistance(System.String,System.String)">
            <summary>
            String edit-distance between str1 and str2
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ExtendedAction`1">
            <summary>
            Represents the action of a move of a Extended Symbolic Finite Transducer (ESFT).
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ExtendedAction`1.Guard">
            <summary>
            Gets the guard of the rule.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ExtendedAction`1.Yields">
            <summary>
            Gets the array of yielded outputs, that is the empty array if there are no outputs.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ExtendedAction`1.Lookahead">
            <summary>
            Gets the lookahead size of the Guard
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAction`1.#ctor">
            <summary>
            Must not be used.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAction`1.#ctor(`0,`0[])">
            <summary>
            Creates a new rule
            </summary>
            <param name="final">true iff the rule represents a final output</param>
            <param name="guard">predicate over input and registers, or registers only when the rule is a final output</param>
            <param name="yields">output elements yielded by the rule</param>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAction`1.Mk(`0,`0[])">
            <summary>
            Creates a new rule representing a guarded register update.
            </summary>
            <param name="guard">predicate over input and registers</param>
            <param name="update">register update</param>
            <param name="yields">(possibly empty) array of output terms yielded by the rule</param>
        </member>
        <member name="F:Microsoft.Automata.ExtendedAutomaton`1.Empty">
            <summary>
            The empty automaton
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ExtendedAutomaton`1.IsEmpty">
            <summary>
            True iff there are no final states
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.Create(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.Automata.ExtendedMove{`0}},System.Boolean,System.Boolean)">
            <summary>
            Create a symbolic automaton.
            </summary>
            <param name="initialState">initial state</param>
            <param name="finalStates">final states</param>
            <param name="moves">moves</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Automata.ExtendedAutomaton`1.MaxState">
            <summary>
            A number that is either equal to or greater than the largest state id used in the SFA
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.RemoveTheState(System.Int32)">
            <summary>
            Remove the state.
            </summary>
            <param name="state">state to be removed, must not be the initial state</param>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.GetAction(System.Int32,System.Int32)">
            <summary>
            Get the condition from the move from source to target
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.EliminateDeadStates">
            <summary>
            Eliminate all non-initial states from the automaton from which no final state is recahable 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.EliminateUnrreachableStates">
            <summary>
            Eliminate all non-initial states from the automaton from which no final state is recahable 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.CheckDeterminism(Microsoft.Automata.IBooleanAlgebraPositive{`0},System.Boolean)">
            <summary>
            Checks that for all states q, if q has two or more outgoing 
            moves then the conditions of the moves are pairwise disjoint, i.e., 
            their conjunction is unsatisfiable. 
            If the check succeeds, sets IsDeterministic to true.
            Throws AutomataException if the FSA is not epsilon-free.
            </summary>
            <param name="solver">used to make conjunctions and to check satisfiability of resulting conditions</param>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.GetPathToSomeFinalState(System.Int32)">
            <summary>
            Returns a non-circular path from source to some final state.
            The path is empty if source is a final state.
            Only the last state of the returned path is a final state.
            May throw AutomataException if the automaton contains dead-states.
            </summary>
            <param name="source">a given source state</param>
        </member>
        <member name="P:Microsoft.Automata.ExtendedAutomaton`1.InitialState">
            <summary>
            The initial state of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.IsFinalState(System.Int32)">
            <summary>
            Returns true iff the state is a final state of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.IsLoopState(System.Int32)">
            <summary>
            Returns true iff there exists a move from state to state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.GetStates">
            <summary>
            Enumerates all states of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.GetMoves">
            <summary>
            Enumerates all moves of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.DescribeState(System.Int32)">
            <summary>
            Returns state.ToString().
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedAutomaton`1.DescribeLabel(`0)">
            <summary>
            Returns lab.ToString(), or the empty string when S is not a value type and lab is null. 
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ExtendedMove`1">
            <summary>
            Represents a move of a extended symbolic finite automaton.
            Can either go to a state or be final
            </summary>
            <typeparam name="LAB">the type of the labels of moves</typeparam>
        </member>
        <member name="F:Microsoft.Automata.ExtendedMove`1.SourceState">
            <summary>
            Source state of the move
            </summary>
        </member>
        <member name="F:Microsoft.Automata.ExtendedMove`1.action">
            <summary>
            Condition of the move
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedMove`1.#ctor(System.Int32,Microsoft.Automata.ExtendedAction{`0})">
            <summary>
            Move function
            </summary>
            <param name="sourceState"></param>
            <param name="condition"></param>
        </member>
        <member name="T:Microsoft.Automata.ExtendedFinalMove`1">
            <summary>
            Represents a final move of a ESFT.
            </summary>
            <typeparam name="LAB">the type of the labels of moves</typeparam>
        </member>
        <member name="M:Microsoft.Automata.ExtendedFinalMove`1.#ctor(System.Int32,Microsoft.Automata.ExtendedAction{`0})">
            <summary>
            Final move
            </summary>
            <param name="sourceState"></param>
            <param name="condition"></param>
        </member>
        <member name="M:Microsoft.Automata.ExtendedFinalMove`1.Equals(System.Object)">
            <summary>
            Returns true if obj is a final move with the same source state, and condition.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedFinalMove`1.GetHashCode">
            <summary>
            override HahsCode
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.ExtendedFinalMove`1.ToString">
            <summary>
            Override to string
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.ExtendedNormalMove`1">
            <summary>
            Represents a non-final move of a ESFT.
            </summary>
            <typeparam name="LAB">the type of the labels of moves</typeparam>
        </member>
        <member name="F:Microsoft.Automata.ExtendedNormalMove`1.TargetState">
            <summary>
            Source state of the move
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedNormalMove`1.#ctor(System.Int32,System.Int32,Microsoft.Automata.ExtendedAction{`0})">
            <summary>
            Final move
            </summary>
            <param name="sourceState"></param>
            <param name="condition"></param>
        </member>
        <member name="M:Microsoft.Automata.ExtendedNormalMove`1.Equals(System.Object)">
            <summary>
            Returns true if obj is a final move with the same source state, and condition.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ExtendedNormalMove`1.GetHashCode">
            <summary>
            override HahsCode
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.ExtendedNormalMove`1.ToString">
            <summary>
            Override to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.GraphAlgorithms.GetStronglyConnectedComponents``1(Microsoft.Automata.Automaton{``0})">
            <summary>
            Computes the strongly connected components of the automaton
            </summary>
            <typeparam name="T"></typeparam>
            <param name="automaton"></param>
            <param name="solver"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.IntSet">
            <summary>
            Represents a set of integers. This is a value class.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IteBagBuilder`1.OpInContext(Microsoft.Automata.BagOpertion,`0,Microsoft.Automata.IteBag{`0},Microsoft.Automata.IteBag{`0})">
            <summary>
            Invariant: algebra.IsSatisfiable(context), assumes that bag1 has no dead branches
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicPartitionRefinement`1">
            <summary>
            Represents a symbolic partition refinement of a set of elements. 
            Sets are not required to be finite but the set type must be associated with a Boolean algebra.
            </summary>
            <typeparam name="S">set type</typeparam>
        </member>
        <member name="M:Microsoft.Automata.SymbolicPartitionRefinement`1.#ctor(Microsoft.Automata.IBooleanAlgebra{`0},`0)">
            <summary>
            Construct a symbolic partition refinement for a given Boolean algebra over S and initial set of elements.
            </summary>
            <param name="solver">given Boolean algebra</param>
            <param name="initialSet">initial set of elements will be one part</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicPartitionRefinement`1.GetRegions">
            <summary>
            Enumerates all individual parts of the partition. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicPartitionRefinement`1.Refine(`0)">
            <summary>
            Refines the current partition with respect to the given set.
            The given set is not required be a subset of the initial set.
            </summary>
            <param name="B">given set</param>
        </member>
        <member name="T:Microsoft.Automata.PartitionRefinement">
            <summary>
            Used by the Miminization algorithm to compute partitions of the state space.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.PartitionRefinement.InitialPart">
            <summary>
            Gets the initial part.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PartitionRefinement.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Creates a new partition refinement.
            </summary>
            <param name="domain">nonempty collection of nonnegative integers</param>
            <param name="maxState">must be the largest element in the domain</param>
        </member>
        <member name="M:Microsoft.Automata.PartitionRefinement.Refine(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Refines the partition with respect to the given set of elements that must be 
            a subset of the original partition.
            Returns pairs [R0,R1] where R0 is the modified original partition and R1 is a nonempty subset..
            </summary>
            <param name="set">given set of elements, the enumeration must not have repetitions</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.PartitionRefinement.GetPart(System.Int32)">
            <summary>
            Returns the part that the given element belongs to.
            </summary>
            <param name="elem">given element</param>
        </member>
        <member name="T:Microsoft.Automata.Part">
            <summary>
            Represents a single part of a partition of a finite set of integers. Used by the PartitionRefinement class.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Part.GetElements">
            <summary>
            Enumerates all the elements in this part.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Part.#ctor(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.Automata.BDDAlgebra,System.Int32)">
            <summary>
            Constructs a new part with the given elements.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Part.#ctor(System.Int32,Microsoft.Automata.BDDAlgebra,System.Int32)">
            <summary>
            Constructs a new part with the given single element.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Part.Add(System.Int32)">
            <summary>
            Add the element to this part.
            </summary>
            <param name="elem">element to be added</param>
        </member>
        <member name="M:Microsoft.Automata.Part.Remove(System.Int32)">
            <summary>
            Remove the element from this part.
            </summary>
            <param name="elem">element to be removed</param>
        </member>
        <member name="P:Microsoft.Automata.Part.Representative">
            <summary>
            Gets a fixed member of the part.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Part.Size">
            <summary>
            Gets the number of elements in this part.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Part.IsEmpty">
            <summary>
            Returns true iff the part is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Part.Update(Microsoft.Automata.Part)">
            <summary>
            Updates the set of elements in this part to the set of the given part.
            </summary>
            <param name="part">given part</param>
        </member>
        <member name="M:Microsoft.Automata.Part.IsEquivalentTo(Microsoft.Automata.Part)">
            <summary>
            Returns true iff this part and the given part contain the same elements.
            </summary>
            <param name="part">given part</param>
        </member>
        <member name="T:Microsoft.Automata.PushdownAutomaton`2">
            <summary>
            Symbolic Push Down Automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.#ctor(Microsoft.Automata.IBooleanAlgebra{`1},System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},`0,System.Collections.Generic.List{`0},System.Collections.Generic.List{Microsoft.Automata.Move{Microsoft.Automata.PushdownLabel{`0,`1}}},System.Boolean)">
            <summary>
            All deadends and unreachable states are eliminated from the states and moves if cleanup is set to true
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.#ctor(Microsoft.Automata.IBooleanAlgebra{`1},Microsoft.Automata.Automaton{Microsoft.Automata.PushdownLabel{`0,`1}},System.Collections.Generic.List{`0},`0)">
            <summary>
            Assumes that the automaton is clean: has no unsatisfiable moves, no dead states, and no unreachable states
            </summary>
        </member>
        <member name="T:Microsoft.Automata.PushdownAutomaton`2.ReachabilityAutomaton">
            <summary>
            The workhorse of the emptiness algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.ReachabilityAutomaton.Saturate">
            <summary>
            Algorithm 'saturate' in Figure 1 from Finkel-Willems-Wolper paper 
            'A Direct Symbolic Approach to Model Checking PushDown Systems'
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.ReachabilityAutomaton.GetWitness">
            <summary>
            Returns a witness if the accepted language is empty.
            Returns null if the language is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.ReachabilityAutomaton.GenerateWitnesses(System.Int32)">
            <summary>
            Returns an enumerator of k random witnesses, or unbounded (default) if k is not positive.
            If the language is empty then the enumeration is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.ReachabilityAutomaton.AddNewEps(System.Tuple{System.Int32,System.Int32},Microsoft.Automata.Sequence{`1})">
            <summary>
            Add new epsilon and maintain its transitive closure.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.IsNonempty(`1[]@)">
            <summary>
            Returns true if the PDA is nonempty and outputs a witness if this is the case.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.GenerateWitnesses(System.Int32)">
            <summary>
            Generate up to k random witnesses accepted by the PDA. If the language is empty 
            then the enumeration is empty. If k is 0 or negative then the enumeration is unbounded.
            Repetitions may occur.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.Intersect(Microsoft.Automata.IMinimalAutomaton{`1}[])">
            <summary>
            Intersects this PDA with all the given NFAs simultaneously. The NFAs are assumed to be epsilon-free.
            The PDA may be arbitrary. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PushdownAutomaton`2.Explore(System.Int32)">
            <summary>
            Explores the PDA and converts it into an automaton, 
            only stacks up to bounded depth are considered.
            </summary>
            <param name="stackDepth">upper bound on reached stack depth, nonpositive value means unbounded and may cause nontermination</param>
        </member>
        <member name="T:Microsoft.Automata.PushdownLabel`2">
            <summary>
            Represents the label of a pushdown automaton move
            </summary>
            <typeparam name="S"></typeparam>
        </member>
        <member name="M:Microsoft.Automata.RegexToSMTConverter.ConvertRegex(System.String)">
            <summary>
            Convert a .Net regex to equivalent SMT lib format expression as a string
            </summary>
            <param name="regex">the given .NET regex pattern</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToSMTConverter.ConvertSeq(System.String)">
            <summary>
            Convert a string to equivalent SMT lib format expression as a sequence of characters.
            </summary>
            <param name="seq">given string that denotes a sequence of characters</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToSMTConverter.EscapeCharSMT(System.Char)">
            <summary>
            Escape a character for SMT lib converter.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SpecialCharacters.ToSubscript(System.Int32)">
            <summary>
            Produces subscript index
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SpecialCharacters.c(System.Int32)">
            <summary>
            Produces 'c' with subscript i
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SpecialCharacters.S(System.Int32)">
            <summary>
            Produces 'S' with subscript i
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SpecialCharacters.q(System.Int32)">
            <summary>
            Produces 'q' with subscript i
            </summary>
        </member>
        <member name="T:Microsoft.Automata.StateDistinguisher_Moore`1">
            <summary>
            Utility for distinguishing states of a deterministic symbolic automaton. Uses Moore's algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher_Moore`1.Initialize">
            <summary>
            Based on MinimizeMoore method/technique.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher_Moore`1.AreDistinguishable(System.Int32,System.Int32,Microsoft.Automata.ConsList{`0}@)">
            <summary>
            Output distinguishability witness for p and q if p and q are distinguishable.
            If return value is true and witness is null then the witness is the empty sequence.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher_Moore`1.AreDistinguishable(System.Int32,System.Int32,System.String@)">
            <summary>
            Output concrete distinguishability witness for p and q if p and q are distinguishable.
            Not supported if selectCharacter function has not been provided.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher_Moore`1.GetAllDistinguishingStrings">
            <summary>
            Return the list of all all distinguishing strings.
            Not supported if selectCharacter function has not been provided.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher_Moore`1.IsDistinguishingString(System.String)">
            <summary>
            Returns true if s is a distinguishing string for some pair of states.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.StateDistinguisher_Moore`1.DistinguisherCount">
            <summary>
            Return the count of distinct distinguishing sequences
            </summary>
        </member>
        <member name="T:Microsoft.Automata.StateDistinguisher`1">
            <summary>
            Utility for distinguishing states of a deterministic symbolic automaton. 
            Uses symbolic partition refinement, based on symbolic minimization from POPL'14.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher`1.GetDistinguishingString(System.Int32,System.Int32)">
            <summary>
            Get the distinguishing string between the two states.
            Assumes that the choice function is defined.
            Returns null if the states are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher`1.#ctor(Microsoft.Automata.Automaton{`0},System.Func{`0,System.Char},System.Boolean,System.Boolean)">
            <summary>
            Creates an instance of state distinguisher for the given dfa.
            </summary>
            <param name="dfa">deterministic automaton</param>
            <param name="choice">choice function for selecting characters from satisfiable predicates</param>
            <param name="optimize">if true then optimizes the computed distinguishing sequences</param>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher`1.ComputeSplitHistory">
            <summary>
            Based on algorithm MinSFA from POPL14.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher`1.GetDistinguishingSequence(System.Int32,System.Int32)">
            <summary>
            Get the distinguishing string between the two states.
            Returns null if the states are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher`1.EnumerateAllDistinguishingSequences">
            <summary>
            Enumerate all the distinguishing sequences between all pairs of nonequivalent states.
            Used for testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher`1.EnumerateAllDistinguishingSequences(System.Int32,System.Int32)">
            <summary>
            Enumerate all the distinguishing sequences between the two states.
            Returns null if the states are equivalent.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher`1.GetAllDistinguishingSequences">
            <summary>
            Returns all the distinguishing sequences.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StateDistinguisher`1.GetAllDistinguishingStrings">
            <summary>
            Returns all the distinguishing strings. Assumes choice function is defined.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STbSimplifier`3.Implies(`1,`1)">
            <summary>
            Returns true if lhs implies rhs for all variables
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PFbuilder1`3.PF1.Implies(Microsoft.Automata.IPF{`1})">
            <summary>
            Returns true if this(inputs,register_in,register_out) implies pf(inputs,register_in,register_out)
            </summary>
        </member>
        <member name="T:Microsoft.Automata.StringUtility">
            <summary>
            Provides some character escaping routines for strings.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StringUtility.Escape(System.Char,System.Boolean)">
            <summary>
            Make an escaped string from a character.
            </summary>
            <param name="c">given character</param>
            <param name="useNumericRepresentationOnly">if true then use numeric hexadecimal escaping of all characters</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.StringUtility.EscapeWithNumericSpace(System.Char)">
            <summary>
            Make an escaped string from a character
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StringUtility.Escape(System.String)">
            <summary>
            Makes an escaped string from a literal string s. 
            Appends '\"' at the start and end of the encoded string.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.StringUtility.Unescape(System.String)">
            <summary>
            Unescapes any escaped characters in in the input string. 
            (Same as System.Text.RegularExpressions.Regex.Unescape)
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ThreeAutomaton`1.FinalState">
            <summary>
            Gets some final state of the automaton
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ThreeAutomaton`1.IsEmpty">
            <summary>
            True iff there are no final states
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.GetApproxMinimalConsistentSFA(Microsoft.Automata.IBooleanAlgebra{`0},System.Int32)">
            <summary>
            Return the approx of the min SFA accepting only the strings accepted by the 3SFA
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.GetSmallestLanguageSFA">
            <summary>
            Return the SFA accepting only the strings accepted by the 3SFA
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.GetBiggestLanguageSFA">
            <summary>
            Return the SFA rejecting only the strings rejected by the 3SFA
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.Create(Microsoft.Automata.IBooleanAlgebra{`0},System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Microsoft.Automata.Move{`0}})">
            <summary>
            Create a three symbolic automaton.
            </summary>
            <param name="initialState">initial state</param>
            <param name="acceptingStates">final states</param>
            <param name="moves">moves</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Automata.ThreeAutomaton`1.MaxState">
            <summary>
            A number that is either equal to or greater than the largest state id used in the SFA
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.MakeInitialStateFinal">
            <summary>
            Mark the initial state as a final state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.AddMove(Microsoft.Automata.Move{`0})">
            <summary>
            Add a new move.
            </summary>
            <param name="move">move to be added</param>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.MkProduct(Microsoft.Automata.ThreeAutomaton{`0},Microsoft.Automata.ThreeAutomaton{`0},Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Make a product of a and b. First removes epsilons from a and b.
            </summary>
            <param name="a">first SFA of the product</param>
            <param name="b">second SFA of the product</param>
            <param name="conj">make the conjunction of two conditions</param>
            <param name="disj">make the disjunction of two conditions, used during initial epsilon elimination</param>
            <param name="isSat">check if a condition is satisfiable, used to keep the result clean</param>
            <returns>the product SFA of a and b</returns>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.MkSum(Microsoft.Automata.ThreeAutomaton{`0},Microsoft.Automata.ThreeAutomaton{`0},Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Make a sum (union) of a and b. Produces an automaton a+b such that L(a+b) = L(a) union L(b)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.Complement">
            <summary>
            Creates the automaton that accepts the complement of L(this).
            </summary>
            <param name="solver">boolean algebra solver over S</param>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.Intersect(Microsoft.Automata.ThreeAutomaton{`0},Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Creates the automaton that accepts the intersection of L(this) and L(B).
            </summary>
            <param name="B">another automaton</param>
            <param name="solver">boolean algebra solver over S</param>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.Union(Microsoft.Automata.ThreeAutomaton{`0},Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Creates the automaton that accepts the union of L(this) and L(B).
            Uses additional epsilon transitions and does not need the solver for S.
            </summary>
            <param name="B">another automaton</param>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.IsEquivalentWith(Microsoft.Automata.ThreeAutomaton{`0},Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Returns true iff this automaton and another automaton B are equivalent
            </summary>
            <param name="B">another autonmaton</param>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.MakeTotal">
            <summary>
            The sink state will be the state with the largest id.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.MkComplement">
            <summary>
            Make a complement of the automaton.
            Assumes that the automaton is deterministic, otherwise throws AutomataException.
            </summary>
            <param name="solver">solver for character constraints</param>
            <returns>Complement of this automaton</returns>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.Minimize(Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Minimization of FAs using a symbolic generalization of Moore's algorithm.
            This is a quadratic algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.MinimizeClassical(Microsoft.Automata.IBooleanAlgebra{`0},System.Int32)">
            <summary>
            Extension of standard minimization of FAs, use timeout.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.GetPathToSomeFinalState(System.Int32)">
            <summary>
            Returns a non-circular path from source to some final state.
            The path is empty if source is a final state.
            Only the last state of the returned path is a final state.
            May throw AutomataException if the automaton contains dead-states.
            </summary>
            <param name="source">a given source state</param>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.ChoosePathToSomeFinalState(Microsoft.Automata.Chooser)">
            <summary>
            Produces a random path of labels from the initial state to some final state.
            Assumes that the automaton is nonempty and does not contain deadends.
            </summary>
            <param name="chooser">uses the chooser for randomizing the choices</param>
        </member>
        <member name="P:Microsoft.Automata.ThreeAutomaton`1.InitialState">
            <summary>
            The initial state of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.IsFinalState(System.Int32)">
            <summary>
            Returns true iff the state is a final state of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.IsRejectingState(System.Int32)">
            <summary>
            Returns true iff the state is a final state of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.IsLoopState(System.Int32)">
            <summary>
            Returns true iff there exists a move from state to state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.GetStates">
            <summary>
            Enumerates all states of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.GetMoves">
            <summary>
            Enumerates all moves of the automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.DescribeState(System.Int32)">
            <summary>
            Returns state.ToString().
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ThreeAutomaton`1.DescribeLabel(`0)">
            <summary>
            Returns lab.ToString(), or the empty string when S is not a value type and lab is null. 
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IUnicodeCategoryTheory`1">
            <summary>
            Maps unicode categories to correspoing character predicates.
            </summary>
            <typeparam name="PRED">predicates</typeparam>
        </member>
        <member name="M:Microsoft.Automata.IUnicodeCategoryTheory`1.CategoryCondition(System.Int32)">
            <summary>
            Gets the unicode category condition for unicode category cat, that must be an integer between 0 and 29
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IUnicodeCategoryTheory`1.WhiteSpaceCondition">
            <summary>
            Gets the white space condition
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IUnicodeCategoryTheory`1.WordLetterCondition">
            <summary>
            Gets the word letter (\w) condition
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IntervalSet">
            <summary>
            Represents a sorted finite set of finite intervals representing characters
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IntervalSet.#ctor(System.Tuple{System.UInt32,System.UInt32}[])">
            <summary>
            Create a new interval set
            </summary>
            <param name="intervals">given intervals</param>
        </member>
        <member name="P:Microsoft.Automata.IntervalSet.Item(System.Int32)">
            <summary>
            Gets the index'th element where index is in [0..Count-1]. 
            Throws IndexOutOfRangeException() if index is out of range.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IntervalSet.Count">
            <summary>
            Number of elements in the set
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IntervalSet.Min">
            <summary>
            The least element in the set, provided Count != 0.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IntervalSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IntervalSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IntervalSet.Serialize">
            <summary>
            Returns a string that can be parsed back to IntervalSet
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IntervalSet.Parse(System.String)">
            <summary>
            Parse the interval set from a string s that was produced with Serialize
            </summary>
            <param name="s">given serialization</param>
        </member>
        <member name="T:Microsoft.Automata.MintermGenerator`1">
            <summary>
            Provides a generic implementation for minterm generation over a given Boolean Algebra.
            </summary>
            <typeparam name="PRED">type of predicates</typeparam>
        </member>
        <member name="M:Microsoft.Automata.MintermGenerator`1.#ctor(Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Constructs a minterm generator for a given Boolean Algebra.
            </summary>
            <param name="ba">given Boolean Algebra</param>
        </member>
        <member name="M:Microsoft.Automata.MintermGenerator`1.GenerateMinterms(`0[])">
            <summary>
            Returns GenerateMinterms(true, preds).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.MintermGenerator`1.GenerateMinterms(System.Boolean,`0[])">
            <summary>
            Given an array of predidates {p_1, p_2, ..., p_n} where n>=0.
            Enumerate all satisfiable Boolean combinations Tuple({b_1, b_2, ..., b_n}, p)
            where p is satisfiable and equivalent to p'_1 &amp; p'_2 &amp; ... &amp; p'_n, 
            where p'_i = p_i if b_i = true and p'_i is Not(p_i) otherwise.
            If n=0 return Tuple({},True).
            </summary>
            <param name="preds">array of predicates</param>
            <param name="useEquivalenceChecking">optimization flag: if true, uses equivalence checking to cluster equivalent predicates; otherwise does not use equivalence checking</param>
            <returns>all minterms of the given predicate sequence</returns>
        </member>
        <member name="T:Microsoft.Automata.Move`1">
            <summary>
            Represents a move of a symbolic finite automaton.
            The value default(L) is reserved to represent the label of an epsilon move.
            Thus if S is a reference type the label of an epsilon move is null.
            </summary>
            <typeparam name="L">the type of the labels on moves</typeparam>
        </member>
        <member name="F:Microsoft.Automata.Move`1.SourceState">
            <summary>
            Source state of the move
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Move`1.TargetState">
            <summary>
            Target state of the move
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Move`1.Label">
            <summary>
            Label of the move
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Move`1.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Transition of an automaton.
            </summary>
            <param name="sourceState">source state of the transition</param>
            <param name="targetState">target state of the transition</param>
            <param name="lab">label of the transition</param>
        </member>
        <member name="M:Microsoft.Automata.Move`1.Create(System.Int32,System.Int32,`0)">
            <summary>
            Creates a move. Creates an epsilon move if label is default(L).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Move`1.Epsilon(System.Int32,System.Int32)">
            <summary>
            Creates an epsilon move. Same as Create(sourceState, targetState, default(L)).
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Move`1.IsEpsilon">
            <summary>
            Returns true if label equals default(S).
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Move`1.IsSelfLoop">
            <summary>
            Returns true if the source state and the target state are identical
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Move`1.Equals(System.Object)">
            <summary>
            Returns true if obj is a move with the same source state, target state, and label.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.OrderedSet`1">
            <summary>
            Represents an ordered set of comparable elements.
            </summary>
            <typeparam name="T">type of element that implements IComparable</typeparam>
        </member>
        <member name="M:Microsoft.Automata.OrderedSet`1.#ctor">
            <summary>
            Creates a new ordered set instance.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.OrderedSet`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements in the enumertion into the set, modifies the set in place.
            </summary>
            <param name="more_elems">elements to add</param>
        </member>
        <member name="M:Microsoft.Automata.OrderedSet`1.Add(`0)">
            <summary>
            Inserts an element to the set in place, by modifying the set.
            </summary>
            <param name="elem">the element to add</param>
        </member>
        <member name="M:Microsoft.Automata.OrderedSet`1.Union(`0[])">
            <summary>
            Returns a new set that contains the new elements and the old elements.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.OrderedSet`1.Union(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns a new set that contains the new elements and the old elements.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.OrderedSet`1.Equals(System.Object)">
            <summary>
            Returns true iff obj is a set with equal set of elements.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.OrderedSet`1.SomeElement">
            <summary>
            Returs some element from a nonempty set, and returns default(T) when the set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.OrderedSet`1.IsSingleton">
            <summary>
            Returns true iff the set has one element.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.OrderedSet`1.IsEmpty">
            <summary>
            Returns true iff the set is empty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.OrderedSet`1.IsEmptyOrSingleton">
            <summary>
            Returns true iff the set is either empty or singleton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.OrderedSet`1.GetElements">
            <summary>
            Enumerates all elements in the set.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.PredicateTrie`1">
            <summary>
            For a given atomic Boolean algebra uses a trie of atoms to map all predicates to unique equivalent representatives.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.PredicateTrie`1.Depth">
            <summary>
            Gets the depth of the trie, that is the number of atoms.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.PredicateTrie`1.LeafCount">
            <summary>
            Gets the number of leaves in the trie. All the leaves are pairwise inequivalent predicates.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PredicateTrie`1.TotalLeafDepth">
            <summary>
            Calculates the sum of all leaf depths.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PredicateTrie`1.AverageNodeDepth">
            <summary>
            Calculates the average depth of a non-null node in the tree of the trie.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.PredicateTrie`1.#ctor(Microsoft.Automata.IBooleanAlgebra{`0})">
            <summary>
            Creates internally an empty trie of atoms to distinguish predicates. Throws AutomataException if algebra.IsAtomic is false.
            </summary>
            <param name="algebra">given atomic Boolean algebra</param>
        </member>
        <member name="M:Microsoft.Automata.PredicateTrie`1.Search(`0)">
            <summary>
            For all p: p is equivalent to Search(p).
            For all p and q: if p is equivalent to q then Search(p) equals Search(q).
            </summary>
            <param name="p">given predicate</param>
        </member>
        <member name="F:Microsoft.Automata.PredicateTrie`1.TrieTree.t0">
            <summary>
            the case when the kth atom does not imply the predicate
            </summary>
        </member>
        <member name="F:Microsoft.Automata.PredicateTrie`1.TrieTree.t1">
            <summary>
            the case when the kth atom implies the predicate
            </summary>
        </member>
        <member name="F:Microsoft.Automata.PredicateTrie`1.TrieTree.k">
            <summary>
            distance from the root, atom identifier for a leaf
            </summary>
        </member>
        <member name="F:Microsoft.Automata.PredicateTrie`1.TrieTree.leaf">
            <summary>
            leaf predicate
            </summary>
        </member>
        <member name="T:Microsoft.Automata.DecisionTree">
            <summary>
            Decision tree for mapping character ranges into corresponding partition block ids
            </summary>
        </member>
        <member name="M:Microsoft.Automata.DecisionTree.Create(Microsoft.Automata.CharSetSolver,Microsoft.Automata.BDD[],System.UInt16)">
            <summary>
            Crteate a decision tree that maps a character into a partion block id
            </summary>
            <param name="solver">character alberbra</param>
            <param name="partition">partition of the whole set of all characters into pairwise disjoint nonempty sets</param>
            <param name="precomputeLimit">upper limit for block ids for characters to be precomputed in an array (default is 0xFF, i.e. extended ASCII)</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.DecisionTree.BST">
            <summary>
            Used in the decision tree to locate minterm ids of nonascii characters
            </summary>
        </member>
        <member name="T:Microsoft.Automata.DecisionTree.PartitionCut">
            <summary>
            Represents a cut of the original partition wrt some interval
            </summary>
        </member>
        <member name="M:Microsoft.Automata.DecisionTree.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.DecisionTree.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BooleanDecisionTree">
            <summary>
            Decision tree for mapping character ranges into corresponding partition block ids
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanDecisionTree.Create(Microsoft.Automata.CharSetSolver,Microsoft.Automata.BDD,System.UInt16)">
            <summary>
            Crteate a Boolean decision tree.
            References to solver and domain are not saved in the resulting decision tree.
            </summary>
            <param name="solver">character alberbra</param>
            <param name="domain">elements that map to true</param>
            <param name="precomputeLimit">upper limit for block ids for characters to be precomputed in an array (default is 0xFF, i.e. extended ASCII)</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BooleanDecisionTree.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BooleanDecisionTree.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialize
            </summary>
        </member>
        <member name="T:Microsoft.Automata.RegexExtensionMethods">
            <summary>
            Provides extension methods for the System.Text.RegularExpressions.Regex class
            </summary>
        </member>
        <member name="P:Microsoft.Automata.RegexExtensionMethods.Context">
            <summary>
            Context is a static field that is reused by the Compile and TryCompile methods and is shared accross regexes.
            To forget the context set its value to null.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.ResetContext(System.Text.RegularExpressions.Regex)">
            <summary>
            Sets the value of the static Context field to null and allows the solver to be garbage collected.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.Compile(System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Regex[])">
            <summary>
            Compiles this regex and possibly other regexes into a common symbolic regex representing their intersection
            </summary>
            <param name="regex">this regex</param>
            <param name="regexes">more regexes to intersect with</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.Compile(System.Text.RegularExpressions.Regex,System.Boolean,System.Boolean,System.Boolean,System.Text.RegularExpressions.Regex[])">
            <summary>
            Compiles this regex and possibly other regexes into a common symbolic regex representing their intersection
            </summary>
            <param name="regex">this regex</param>
            <param name="regexes">more regexes to intersect with</param>
            <param name="keepAnchors">if false missing anchors are replaced by .* else just omitted</param>
            <param name="unwindLowerBounds">if true then lower bounds of loops are unwound</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.TryCompile(System.Text.RegularExpressions.Regex,Microsoft.Automata.RegexMatcher@,System.String@,System.Text.RegularExpressions.Regex[])">
            <summary>
            Tries to compile a regex into a symbolic regex
            </summary>
            <param name="regex">given regex</param>
            <param name="result">if the return value is true then this is the result of compilation</param>
            <param name="whyfailed">if the return value is false then this is the reason why compilation failed</param>
            <param name="regexes">other regexes to be intersected with given regex</param>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.IsCompileSupported(System.Text.RegularExpressions.Regex,System.String@)">
            <summary>
            Returns true if the regex can be compiled into a symbolic regex.
            </summary>
            <param name="regex">given regex</param>
            <param name="whynot">if the return value is false, reason why compilation is not supported</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.Display(System.Text.RegularExpressions.Regex,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Display the automaton of the regex in dgml.
            </summary>
            <param name="regex">given regex</param>
            <param name="name">name for the automaton and the dgml file</param>
            <param name="minimize">minimize (and determinize) if true</param>
            <param name="determinize">determinize if true</param>
            <param name="removeepsilons">remove epsilon moves if true</param>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.GenerateCpp(System.Text.RegularExpressions.Regex,System.Int32)">
            <summary>
            Generate c++ matcher code for the given regex. Returns the empty string if the compilation fails.
            </summary>
            <param name="regex">given regex</param>
            <param name="timeout">timeout in ms, 0 means no timeout and is the default</param>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.GenerateRandomMember(System.Text.RegularExpressions.Regex,System.String,System.Int32,System.Int32)">
            <summary>
            Generate a random member accepted by the regex
            </summary>
            <param name="regex">given regex</param>
            <param name="maxUnroll">maximum nr of times a loop is unrolled</param>
            <param name="cornerCaseProb">inverse of pobability of taking a corner case (lower/upper bound) of the number of iterations a loop may be unrolled.</param>
            <param name="charClassRestriction">restrict all generated members to this character class (null means no restriction)</param>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.GenerateRandomDataSet(System.Text.RegularExpressions.Regex,System.Int32,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generate a dataset of random members accepted by the regex
            </summary>
            <param name="regex">given regex</param>
            <param name="size">number of members</param>
            <param name="maxUnroll">maximum nr of times a loop is unrolled</param>
            <param name="cornerCaseProb">inverse of pobability of taking a corner case (lower/upper bound) of the number of iterations a loop may be unrolled.</param>
            <param name="charClassRestriction">restrict all generated members to this character class (null means no restriction)</param>
            <param name="maxSamplingIter">Maximum number of iterations in order to collect the requested number of samples</param>
        </member>
        <member name="M:Microsoft.Automata.RegexExtensionMethods.Complement(System.Text.RegularExpressions.Regex,System.Int32)">
            <summary>
            Returns a regex that accepts the complement of this regex.
            </summary>
            <param name="regex">this regex</param>
            <param name="timeout">timeout to complement in ms</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.RegexToAutomatonBuilder`2">
            <summary>
            Builder from elements of type T into automata over S. 
            S is the type of elements of an effective Boolean algebra.
            T is the type of an AST of regexes.
            Used as the main building block for converting regexes to automata over S.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.#ctor(Microsoft.Automata.IBooleanAlgebra{`1},System.Func{`0,Microsoft.Automata.Automaton{`1}})">
            <summary>
            Create a new incremental automata builder.
            </summary>
            <param name="solver">Effective Boolean algebra over S.</param>
            <param name="callback">The callback function is assumed to map regex nodes to corresponding methods of this builder.</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.Reset">
            <summary>
            Resets the automata builder.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkUnion(`0[])">
            <summary>
            Builds an automaton equivalent to the regex r[0] | r[1] | ... | r[r.Length-1], 
            returns the automaton of the empty language when r is empty.
            </summary>
            <param name="r">regular expression nodes</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkConcatenate(`0[],System.Boolean)">
            <summary>
            Builds an automaton equivalent to the regex r[0]r[1] ... r[r.Length-1], 
            returns the automaton accepting only the empty word when r is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkEmptyWord">
            <summary>
            Builds an automaton equivalent to the regex (), 
            Same as MkSeq().
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkFull">
            <summary>
            Builds an automaton that accepts all words.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkEmptyLang">
            <summary>
            Builds an automaton that accepts nothing.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkSeq(`1[])">
            <summary>
            Builds an automaton equivalent to the regex s[0]s[1] ... s[r.Length-1], 
            returns the automaton accepting only the empty word when s is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkLoop(`0,System.Int32,System.Int32)">
            <summary>
            Builds an automaton equivalent to the regex r{m,n}, or r{m,} when n is int.MaxValue;
            r{0,int.MaxValue} is the same as r*; 
            r{1,int.MaxValue} is the same as r+.
            </summary>
            <param name="r">regular expression node</param>
            <param name="m">lower loop bound</param>
            <param name="n">upper loop bound</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkOneLoop(`1,System.Int32,System.Int32)">
            <summary>
            Builds an automaton equivalent to the regex s{m,n}, or s{m,} when n is int.MaxValue;
            s{0,int.MaxValue} is the same as s*; 
            s{1,int.MaxValue} is the same as s+.
            </summary>
            <param name="s">condition corresponding to a set of characters</param>
            <param name="m">lower loop bound</param>
            <param name="n">upper loop bound</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkBol(`1)">
            <summary>
            Builds a start of line anchor automaton (^ in multiline mode)
            </summary>
            <param name="newLineCond">condition that is true only for a newline character</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkEol(`1)">
            <summary>
            Builds an end of line anchor automaton ($ in multiline mode)
            </summary>
            <param name="newLineCond">condition that is true only for a newline character</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkEnd">
            <summary>
            Builds an end anchor automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkBeginning">
            <summary>
            Builds a start anchor automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonBuilder`2.MkWordBoundary">
            <summary>
            Builds a word boundary automaton.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.RegexToAutomatonConverter`1">
            <summary>
            Provides functionality to convert .NET regex patterns to corresponding symbolic finite automata and symbolic regexes
            </summary>
        </member>
        <member name="P:Microsoft.Automata.RegexToAutomatonConverter`1.Solver">
            <summary>
            The character solver associated with the regex converter
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.#ctor(Microsoft.Automata.ICharAlgebra{`0},Microsoft.Automata.IUnicodeCategoryTheory{`0})">
            <summary>
            Constructs a regex to symbolic finite automata converter
            </summary>
            <param name="solver">solver for character constraints</param>
            <param name="categorizer">maps unicode categories to corresponding character conditions</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.Convert(System.String)">
            <summary>
            Converts a .NET regex pattern into an eqivalent symbolic automaton.
            Same as Convert(regex, RegexOptions.None).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertString(System.String)">
            <summary>
            Converts a single string into an automaton that accepts that string and no other strings.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.Convert(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Convert a regex pattern to an equivalent symbolic finite automaton
            </summary>
            <param name="regex">the given .NET regex pattern</param>
            <param name="options">regular expression options for the pattern</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.Convert(System.String,System.Text.RegularExpressions.RegexOptions,System.Boolean)">
            <summary>
            Convert a regex pattern to an equivalent symbolic finite automaton
            </summary>
            <param name="regex">the given .NET regex pattern</param>
            <param name="options">regular expression options for the pattern</param>
            <param name="keepBoundaryStates">used for testing purposes, when true boundary states are not eliminated</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.EliminateBoundaryStates(Microsoft.Automata.Automaton{`0})">
            <summary>
            Must be called if aut was created with keepBoundaryStates=true.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertNodeMulti(System.Text.RegularExpressions.RegexNode)">
            <summary>
            Sequence of characters in node._str
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertNodeNotone(System.Text.RegularExpressions.RegexNode)">
            <summary>
            Matches chacter any character except node._ch
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertNodeOne(System.Text.RegularExpressions.RegexNode)">
            <summary>
            Matches only node._ch
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertToSymbolicRegex(System.String,System.Text.RegularExpressions.RegexOptions,System.Boolean)">
            <summary>
            Convert a regex pattern to an equivalent symbolic regex
            </summary>
            <param name="regex">the given .NET regex pattern</param>
            <param name="options">regular expression options for the pattern (default is RegexOptions.None)</param>
            <param name="keepAnchors">if false (default) then anchors are replaced by equivalent regexes</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertToSymbolicRegex(System.Text.RegularExpressions.Regex,System.Boolean,System.Boolean)">
            <summary>
            Convert a .NET regex into an equivalent symbolic regex
            </summary>
            <param name="regex">the given .NET regex</param>
            <param name="keepAnchors">if false (default) then anchors are replaced by equivalent regexes</param>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertNodeMultiToSymbolicRegex(System.Text.RegularExpressions.RegexNode,System.Boolean)">
            <summary>
            Sequence of characters in node._str
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertNodeNotoneToSymbolicRegex(System.Text.RegularExpressions.RegexNode)">
            <summary>
            Matches chacter any character except node._ch
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.ConvertNodeOneToSymbolicRegex(System.Text.RegularExpressions.RegexNode)">
            <summary>
            Matches only node._ch
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.MkIfThenElse(Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.SymbolicRegexNode{`0})">
            <summary>
            Make an if-then-else regex (?(cond)left|right)
            </summary>
            <param name="cond">condition</param>
            <param name="left">true case</param>
            <param name="right">false case</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverter`1.MkSingleton(`0)">
            <summary>
            Make a singleton sequence regex
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverterCharSet.Describe(Microsoft.Automata.BDD)">
            <summary>
            Describe the bdd as a regex character set
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverterCharSet.GenerateMember(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Generates a random member accepted by fa. 
            Assumes that fa has no dead states, or else termination is not guaranteed.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverterRanges.Describe(System.Collections.Generic.HashSet{System.Tuple{System.Char,System.Char}})">
            <summary>
            Describe range set
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverterRanges.GenerateMember(Microsoft.Automata.Automaton{System.Collections.Generic.HashSet{System.Tuple{System.Char,System.Char}}})">
            <summary>
            Generates a random member accepted by fa. 
            Assumes that fa has no dead states, or else termination is not guaranteed.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverterHashSet.Describe(System.Collections.Generic.HashSet{System.Char})">
            <summary>
            Describe hash set
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexToAutomatonConverterHashSet.GenerateMember(Microsoft.Automata.Automaton{System.Collections.Generic.HashSet{System.Char}})">
            <summary>
            Generates a random member accepted by fa. 
            Assumes that fa has no dead states, or else termination is not guaranteed.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Rex.RexEngine">
            <summary>
            Provides a member generator for regexes
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.#ctor(Microsoft.Automata.BitWidth)">
            <summary>
            Create a regex member generator for the given character encoding.
            </summary>
            <param name="encoding">character encoding</param>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.GenerateMember(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Generates a random member accepted by fa. 
            Assumes that fa has no dead states, or else termination is not guaranteed.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.GenerateMemberUniformly(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Generates a random member accepted by fa with uniform distribution among strings accepted by the sfa. 
            Assumes that the fa is deterministic and loopfree.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.GenerateMembers(System.Text.RegularExpressions.RegexOptions,System.Int32,System.String[])">
            <summary>
            Generates at most k distinct strings that match all the given regexes.
            The enumeration is empty if there are no strings that match all the regexes.
            </summary>
            <param name="options">regular expression options</param>
            <param name="k"> number of members to be generated</param>
            <param name="regexes">given regexes</param>
            <returns>enumeration of strings each of which matches all the regexes</returns>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.GenerateMembers(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},System.Int32)">
            <summary>
            Generates at most k distinct strings in the language of the sfa.
            The enumeration is empty if the language is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.CreateFromRegexes(System.Text.RegularExpressions.RegexOptions,System.String[])">
            <summary>
            Create a product of the automata of the given regexes.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.CreateFromRegexes(System.String[])">
            <summary>
            Create a product of the automata of the given regexes.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Invokes System.Text.RegularExpressions.Regex.IsMatch(input, regex, options)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.SerializeDAG(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Create a string encoding of the given automaton with probabilities.
            </summary>
            <param name="aut">deterministic and loopfree automaton</param>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.DeserializeDAG(System.String)">
            <summary>
            Recreate an automaton from a string that has been produced with SerializeDAG.
            </summary>
            <param name="dag">string encoding of a deterministic and loopfree automaton with probabilities</param>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.Minimize(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Determinize and then minimize the automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.Complement(Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Complement the automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.Intersect(Microsoft.Automata.Automaton{Microsoft.Automata.BDD}[])">
            <summary>
            Intersect two (or more) automata. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.AreEquivalent(Microsoft.Automata.Automaton{Microsoft.Automata.BDD},Microsoft.Automata.Automaton{Microsoft.Automata.BDD})">
            <summary>
            Returns true iff aut1 and aut2 accept the same set of strings.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.Escape(System.Char)">
            <summary>
            Make an escaped string from a character
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexEngine.Escape(System.String)">
            <summary>
            Make an escaped string from a string
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Rex.RexSettings">
            <summary>
            Provides settings for Rex
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexSettings.#ctor">
            <summary>
            Creates and instance of RexSettings with default values for all settings.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexSettings.ParseFromCommandlineArguments(System.String[],Microsoft.Automata.Rex.RexSettings@)">
            <summary>
            Parse the given commandline arguments and create the corresponding settings object.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rex.RexSettings.#ctor(System.String[])">
            <summary>
            Creates and instance of RexSettings for the given regexes using default values for other settings.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.regexes">
            <summary>
            Explicit input regexes, must be a nonempty collection of regexes if no regexfile is given. 
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.regexfile">
            <summary>
            File where input regexes are stored one regex per line.
            This argument must be given if no regexes are given explicitly.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.options">
            <summary>
            Zero or more regular expression options. Default is no options or equivalently RegexOptions.None.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.k">
            <summary>
            Number of members to generate. Default is 1.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.file">
            <summary>
            File where the generated strings are stored, if omitted, the output it directed to the console.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.encoding">
            <summary>
            The character encoding to be used; determines the number of bits, ASCII:7, CP437:8, Unicode:16. 
            Default is Unicode.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.uniform">
            <summary>
            If true then the elements are generated uniformly at random (default is false) and the automaton may not have loops.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.dot">
            <summary>
            Name of output dot file of the finite automaton for the regex(es).
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.intersect">
            <summary>
            If set, intersect the regexes; otherwise treat the regexes independently and generate k members for each. Default is false.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rex.RexSettings.game">
            <summary>
            If set, other options are ignored and there must be two given regexes r1 and r2. Generate 2 witnesses in each region of the Venn diagram for L(r1), L(r2).  Default is false.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Rule`1">
            <summary>
            Represents the label of a move of a Symbolic Transducer (ST).
            STs have flat rules.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Rule`1.k">
            <summary>
            when nonfinal, indicates the number of inputs
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Rule`1.IsFinal">
            <summary>
            True iff the rule describes a final output.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Rule`1.Guard">
            <summary>
            Gets the guard of the rule.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Rule`1.Yields">
            <summary>
            Gets the array of yielded outputs, that is the empty array if there are no outputs.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Rule`1.Update">
            <summary>
            Gets the symbolic register update, that is default(TERM), if no registers are used or IsFinal is true.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rule`1.#ctor">
            <summary>
            Must not be used.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Rule`1.#ctor(System.Boolean,`0,`0[],`0)">
            <summary>
            Creates a new rule
            </summary>
            <param name="final">true iff the rule represents a final output</param>
            <param name="guard">predicate over input and registers, or registers only when the rule is a final output</param>
            <param name="yields">output elements yielded by the rule</param>
            <param name="update">register update</param>
        </member>
        <member name="M:Microsoft.Automata.Rule`1.MkFinal(`0,`0[])">
            <summary>
            Creates a new rule representing a final output.
            </summary>
            <param name="guard">predicate over registers</param>
            <param name="yields">(possibly empty) array of output terms yielded by the rule</param>
        </member>
        <member name="M:Microsoft.Automata.Rule`1.Mk(`0,`0,`0[])">
            <summary>
            Creates a new rule representing a guarded register update.
            </summary>
            <param name="guard">predicate over input and registers</param>
            <param name="update">register update</param>
            <param name="yields">(possibly empty) array of output terms yielded by the rule</param>
        </member>
        <member name="T:Microsoft.Automata.BranchingRuleKind">
            <summary>
            There are four kinds of branching rules
            </summary>
        </member>
        <member name="T:Microsoft.Automata.BranchingRule`1">
            <summary>
            Abstract base class of branching rules.
            STbs have branching rules.
            </summary>
            <typeparam name="TERM">the type of terms</typeparam>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.EnumerateMoves(Microsoft.Automata.IContextCore{`0},System.Int32,`0)">
            <summary>
            Enumerates the underlying branches as moves from the give source state and guard. 
            Excludes all raise rules.
            </summary>
            <param name="solver">solver for composing conditions</param>
            <param name="source">source states of the moves</param>
            <param name="guard">initial guard of the moves</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.ExctractRaiseCondition(Microsoft.Automata.IContextCore{`0},`0)">
            <summary>
            Extracts the condition under which the rule raises an exception.
            </summary>
            <param name="solver">solver for composing conditions</param>
            <param name="guard">initial guard of the moves</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Automata.BranchingRule`1.Yields">
            <summary>
            Gets the sequence of output terms yielded by this rule.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BranchingRule`1.Register">
            <summary>
            Gets the register update produced by this rule.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BranchingRule`1.State">
            <summary>
            Gets the target state of this rule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.EnumerateStates">
            <summary>
            Enumerates all the target states that occur in the rule.
            Yields a state as many times as it occurs in the rule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.GetAllStates">
            <summary>
            Returns a list of all target states, without repetitions, that occur in the rule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.Concretize(Microsoft.Automata.IContextCore{`0},System.Func{`0,`0},System.Func{`0,`0},System.Func{System.Int32,`0,System.Int32},`0,`0)">
            <summary>
            Concretize the rule with respect to the given values.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.ReplaceAllStatesAndRegisters(System.Int32,`0)">
            <summary>
            Replace all states in the rule by q and all registers by r.
            </summary>
            <param name="q">given state</param>
            <param name="r">given register value</param>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.Subst(Microsoft.Automata.IContextCore{`0},`0[])">
            <summary>
            Create an instance of the rule by applying the substitution to all the components
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.Subst(`0,Microsoft.Automata.IContextCore{`0},`0[])">
            <summary>
            Create an instance of the rule by applying the substitution to all the components
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.ApplyInput(Microsoft.Automata.IContextCore{`0},`0,`0)">
            <summary>
            Create an instance of the rule by replacing the input variable x with the new input term t
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BranchingRule`1.IsPartial">
            <summary>
            Returns true iff the rule contains a RaiseRule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.BranchingRule`1.IsTrueForAllRegisterUpdates(System.Predicate{`0})">
            <summary>
            Returns true iff for all register updates U, proj(U) is a ground value, i.e., independent 
            of the previous register and independent of the input character.
            </summary>
            <param name="prde">must be a valid prdicate over registers</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.BaseRule`1">
            <summary>
            Basic rule of an STb. 
            </summary>
            <typeparam name="TERM">the type of terms on the labels</typeparam>
        </member>
        <member name="M:Microsoft.Automata.BaseRule`1.#ctor(Microsoft.Automata.Sequence{`0},`0,System.Int32)">
            <summary>
            Creates a new basic rule.
            </summary>
            <param name="yields">the sequence of output terms yielded by this rule</param>
            <param name="register">the register update produced by this rule</param>
            <param name="state">the target state of this rule</param>
        </member>
        <member name="P:Microsoft.Automata.BaseRule`1.Yields">
            <summary>
            Gets the sequence of output terms yielded by this rule.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BaseRule`1.Register">
            <summary>
            Gets the register update produced by this rule.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.BaseRule`1.State">
            <summary>
            Gets the target state of this rule.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IteRule`1">
            <summary>
            If-then-else rule of an STb.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IteRule`1.Condition">
            <summary>
            The branch condition of the rule.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IteRule`1.TrueCase">
            <summary>
            The branch taken when branch condition evaluates to true.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IteRule`1.FalseCase">
            <summary>
            The branch taken when branch condition evaluates to false.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.UndefRule`1">
            <summary>
            Rule that raises an exception. The resulting state is a nonaccepting state.
            </summary>
            <typeparam name="TERM">the type of terms on the labels</typeparam>
        </member>
        <member name="F:Microsoft.Automata.UndefRule`1.Default">
            <summary>
            Fixed raise rule with Id=1 and Exc="E".
            </summary>
        </member>
        <member name="M:Microsoft.Automata.UndefRule`1.#ctor(System.String)">
            <summary>
            Creates a new rule that raises an exception. The new raise rule has a new identifier.
            </summary>
            <param name="exc">Description of the exception raised by the rule.</param>
        </member>
        <member name="M:Microsoft.Automata.UndefRule`1.#ctor">
            <summary>
            Creates a new raise rule with Exc="E".
            </summary>
        </member>
        <member name="P:Microsoft.Automata.UndefRule`1.Exc">
            <summary>
            Description of the exception raised by the rule.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.UndefRule`1.Id">
            <summary>
            Identifier of this raise rule.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SwitchRule`1">
            <summary>
            Describes a switch statement.
            </summary>
            <typeparam name="TERM"></typeparam>
        </member>
        <member name="T:Microsoft.Automata.Sequence`1">
            <summary>
            A value class representing a sequence of elements of type T.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Sequence`1.Item(System.Int32)">
            <summary>
            Gets the i'th element of the sequence, where i must be between 0 and Length-1.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Sequence`1.Length">
            <summary>
            The number of elements in the sequence
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Sequence`1.IsEmpty">
            <summary>
            Returns true iff the sequence is empty.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Sequence`1.Empty">
            <summary>
            The empty sequence.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.#ctor(`0[])">
            <summary>
            Creates a new sequence containing the given elements.
            </summary>
            <param name="elems">given elements of the sequence</param>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new sequence containing the given elements.
            </summary>
            <param name="elems">given elements of the sequence</param>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Append(Microsoft.Automata.Sequence{`0})">
            <summary>
            Append seq at the end of this sequence
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Append(`0[])">
            <summary>
            Creates a new sequence by appending the given elements at the end of this sequence.
            </summary>
            <param name="seq">elements to be appended at the end of this sequence</param>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Append(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new sequence by appending seq at the end of this sequence.
            </summary>
            <param name="seq">elements to be appended</param>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Replace(System.Int32,`0)">
            <summary>
            Returns the sequence where the i'th element, starting with 0, has been replaced by e. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Suffix(System.Int32)">
            <summary>
            Returns the suffix of the sequence starting from the i'th element. Indexing starts with 0.
            
            Returns the empty sequence if i is >= the length of this sequence.
            
            Returns this sequence if 0 >= i.
            </summary>
            <param name="i">index of the start position</param>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Equals(System.Object)">
            <summary>
            Two sequences are equal iff they have the same length and their i'th elements are equal for all i.
            </summary>
            <summary>
            Two sequences are equal iff they have the same length and their i'th elements are equal for all i.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.EqAllButOne(Microsoft.Automata.Sequence{`0})">
            <summary>
            Returns the index i if there exists i such that !this[i].Equals(s[i]) but this[j].Equals(s[j]) for all j != i.
            Returns -1 otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.MaximalCommonPrefix(Microsoft.Automata.Sequence{`0})">
            <summary>
            Reuturns the maximal common prefix between this sequence and another sequence
            </summary>
            <typeparam name="S">element type</typeparam>
            <param name="that">the other sequence</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.TryGetElement(System.Predicate{`0},`0@)">
            <summary>
            Try to find an element in the sequence for which pred is true.
            If such an element exists then true is returned and elem is the first such element 
            else false is retured and elem is assigned default(T).
            </summary>
            <param name="pred">given predicate</param>
            <param name="elem">the found element if true is returned</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Exists(System.Predicate{`0})">
            <summary>
            Returns true if there exists an element in the sequence for which pred is true.
            Returns false otherwise.
            </summary>
            <param name="pred">given predicate</param>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.TrueForAll(System.Predicate{`0})">
            <summary>
            Returns true if the predicate holds for all elements in the sequence.
            Returns false otherwise.
            </summary>
            <param name="pred">given predicate</param>
        </member>
        <member name="P:Microsoft.Automata.Sequence`1.First">
            <summary>
            The first element of the sequence
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Rest">
            <summary>
            The rest of the sequence
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.Reverse">
            <summary>
            Reverse the sequence
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Sequence`1.AppendAll(Microsoft.Automata.Sequence{`0}[])">
            <summary>
            Append all the sequences into a single serquence
            </summary>
            <param name="seqs">given sequences to be appended</param>
        </member>
        <member name="T:Microsoft.Automata.SFA`3">
            <summary>
            Symbolic Finite Automaton (SFA) associated with a given SMT solver.
            Contains core algorithms for manipulating SFAs.
            </summary>
            <typeparam name="FUNC">function declarations, each function declaration has domain and range sorts</typeparam>
            <typeparam name="TERM">terms, each term has a fixed sort</typeparam>
            <typeparam name="SORT">sorts correspond to different subuniverses of elements</typeparam>
        </member>
        <member name="P:Microsoft.Automata.SFA`3.Name">
            <summary>
            Gets or sets the name of the SFA
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SFA`3.Automaton">
            <summary>
            Underlying basic automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.#ctor(Microsoft.Automata.IContext{`0,`1,`2},`2,System.String,Microsoft.Automata.Automaton{`1})">
            <summary>
            Creates a new SFA.
            </summary>
            <param name="solver">solver of character constraints</param>
            <param name="sort">input element sort</param>
            <param name="name">name of the automaton</param>
            <param name="autom">underlying basic automaton</param>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.#ctor(Microsoft.Automata.IContext{`0,`1,`2},`2,Microsoft.Automata.Automaton{`1})">
            <summary>
            Creates the SFA(solver,sort,"SFA",autom) 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.Union(Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Creates an automaton that accepts the union of L(this) and L(B)
            </summary>
            <param name="B">given automaton</param>
            <returns>an automaton that accepts the union of L(this) and L(B)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.IntersectWith(Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Creates an automaton that accepts the intersection of L(this) and L(B)
            </summary>
            <param name="B">given automaton</param>
            <returns>an automaton that accepts the intersection of L(this) and L(B)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.Minus(Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Creates an automaton that accepts L(this)\L(B)
            </summary>
            <param name="B">given automaton to subtract from current automaton</param>
            <returns>an automaton that accepts L(this)\L(B)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.op_Subtraction(Microsoft.Automata.SFA{`0,`1,`2},Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Creates an SFA that accepts L(A)\L(B)
            </summary>
            <param name="A">given automaton to subtract from</param>
            <param name="B">subtractor automaton</param>
            <returns>an automaton that accepts L(A)\L(B)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.IsSubsetOf(Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Returns true if the language of the current SFA is a subset of L(A)
            </summary>
            <param name="A">superset automaton</param>
            <returns>true if L(this) is subset of L(A)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.op_LessThanOrEqual(Microsoft.Automata.SFA{`0,`1,`2},Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Returns true if L(A) is a subset of L(B)
            </summary>
            <param name="A">subset automaton</param>
            <param name="B">superset automaton</param>
            <returns>true if L(A) is subset of L(A)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.op_GreaterThanOrEqual(Microsoft.Automata.SFA{`0,`1,`2},Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Returns true if L(B) is a subset of L(A)
            </summary>
            <param name="A">superset automaton</param>
            <param name="B">subset automaton</param>
            <returns>true if L(B) is subset of L(A)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.op_LessThan(Microsoft.Automata.SFA{`0,`1,`2},Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Returns true if L(A) is a proper subset of L(B)
            </summary>
            <param name="A">subset automaton</param>
            <param name="B">superset automaton</param>
            <returns>true if L(A) is a proper subset of L(A)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.op_GreaterThan(Microsoft.Automata.SFA{`0,`1,`2},Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Returns true if L(B) is a proper subset of L(A)
            </summary>
            <param name="A">superset automaton</param>
            <param name="B">subset automaton</param>
            <returns>true if L(B) is a proper subset of L(A)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.op_Multiply(Microsoft.Automata.SFA{`0,`1,`2},Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Creates an automaton that accepts the intersection of L(A) and L(B)
            </summary>
            <param name="A">first argument of the intersection</param>
            <param name="B">second argument of the intersection</param>
            <returns>an automaton that accepts the intersection of L(A) and L(B)</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.ShowGraph(System.Int32)">
            <summary>
            Saves the automaton in <paramref name="Name"/>.dgml file in the working directory
            and opens the file in a new process.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SFA`3.IsEmpty">
            <summary>
            Returns true if the automaton accepts no strings
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.EliminateEpsilons">
            <summary>
            Eliminate epsilon moves fom the automaton
            </summary>
            <returns>equivalent automaton without epsilon-moves</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.Complement">
            <summary>
            Complement the automaton, the resulting SFA accepts all strings not accepted by this SFA
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.op_LogicalNot(Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Creates an automaton that accepts the complement of the language of A.
            </summary>
            <param name="A">automaton to be complemented</param>
            <returns>complement of A</returns>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.Determinize">
            <summary>
            Creates an equivalent deterministic automaton
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.MakeTotal">
            <summary>
            Creates an equivalent total automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.Minimize">
            <summary>
            Creates an equivalent minimal automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.MinimizeMoore(System.Int32)">
            <summary>
            Creates an equivalent minimal automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.MinimizeHopcroft(System.Int32)">
            <summary>
            Creates an equivalent minimal automaton.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.NormalizeLabels">
            <summary>
            Normalize the labels.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.AssertTheory">
            <summary>
            Assert the theory of the SFA as an auxiliary background theory to the given SMT solver.
            Reasserts the theory if the acceptor is not is scope.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SFA`3.Acceptor">
            <summary>
            Gets the symbolic acceptor of the SFA.
            A relation symbol with one argument with sort InputListSort.
            Assumes that the theory has been asserted.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.MkAccept(`1)">
            <summary>
            Constructs the automaton acceptor atom 'Acceptor(inList)' for the SFA.
            Assumes that the theory has been asserted and is in scope.
            </summary>
            <param name="inList">any term of sort InputListSort</param>
        </member>
        <member name="P:Microsoft.Automata.SFA`3.Solver">
            <summary>
            Given SMT solver of the SFA.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SFA`3.InputSort">
            <summary>
            Sort of the input elements in lists accepted by the SFA.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SFA`3.InputListSort">
            <summary>
            Sort of the input lists accepted by the SFA.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.ChoosePathToSomeFinalState">
            <summary>
            Choose a path of symbolic terms from the initial state to some final state. 
            Uses Solver.Chooser to control the random choices.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SFA`3.Concretize(System.Int32)">
            <summary>
            Concertize the SFA by including at most k characters in the label.
            </summary>
            <param name="k">upper limit on the number of included characters in the output automaton, when 0 or negative then include all elements</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.ST`3">
            <summary>
            Symbolic Transducer (ST).
            Contains methods for constructing and core algorithms for manipulating STs.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.STb">
            <summary>
            Gets or sets the underlying STb, or null if it does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.ToSTb">
            <summary>
            Convert the ST into an STb. If the ST is nondeterministic then the transformation is incorrect.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.Solver">
            <summary>
            The associated SMT solver.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.GetNonFinalMovesFrom(System.Int32)">
            <summary>
            Enumerate all moves of nonfinal rules from the given state.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.UpdateMaxLookahead">
            <summary>
            Updates the size of the max lookahead
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.GetFinalRules(System.Int32)">
            <summary>
            Enumerate all rules that contain the final yields from the given state.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.YieldsAreEmpty">
            <summary>
            Returns true iff the yields of all rules are empty. 
            In other words, the ST corresponds to an automaton with registers that does not yield any outputs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.MkId(Microsoft.Automata.IContext{`0,`1,`2},`2)">
            <summary>
            Cteate the identity SFT I for the sort such that I(x) = x for all sequences x of elements of the given sort.
            </summary>
            <param name="solver">underlying label theory</param>
            <param name="sort">input and output sort</param>
        </member>
        <member name="M:Microsoft.Automata.ST`3.AssertTheory">
            <summary>
            Defines axioms for nil and cons separately.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.AssertTheory2">
            <summary>
            Uses most general patterns for axioms.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.DefineSTAcceptor">
            <summary>
            Uses fixed patterns nil and cons(x,w) for the input list. Guarantees termination.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.ST`3.DefineSTAcceptor2">
            <summary>
            Uses the most general pattern for axioms without constraints on argument lists.
            Relies on the solvers internal proof search engine to guarantee termination.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.DefineProdSTAcceptor">
            <summary>
            Uses the most general pattern for axioms without constraints on argument lists.
            Defines an acceptor with two outputs for the product case.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.MkAccept(`1,`1)">
            <summary>
            Constructs the transducer acceptor atom 'Acceptor(inList, outList)' for the ST.
            Assumes that the theory has been asserted and is in scope.
            </summary>
            <param name="inList">any term of sort InputListSort</param>
            <param name="outList">any term of sort OutputListSort</param>
        </member>
        <member name="M:Microsoft.Automata.ST`3.DescribeLabel(Microsoft.Automata.Rule{`1})">
            <summary>
            Describes the rule as pp(Guard)/[pp(Yields)];pp(Update)
            where pp is the given TERM pretty printer and where ';pp(Update)' is omitted if Update=null.
            If the label is final, the guard is true, and there are no yields then the output is the empty string.
            If the label is final the the update is omitted, because then Update=null..
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.op_Addition(Microsoft.Automata.ST{`0,`1,`2},Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Creates a symbolic composition of <paramref name="A"/> with <paramref name="B"/>.
            Such that forall s, A+B(s) = B(A(s))
            </summary>
            <param name="A">first ST</param>
            <param name="B">second ST</param>
            <returns>A+B is such that A+B(s) = B(A(s)) for all s</returns>
        </member>
        <member name="P:Microsoft.Automata.ST`3.IsRegisterFree">
            <summary>
            Returns true iff the ST is an SFT, i.e., the register sort is unitsort (register is not used).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Compose(Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Composes this=A with B, the result is A+B such that A+B(s) = B(A(s)) for all s.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Product(Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Makes a parallel product composition of this ST with A.
            Assumes that this and B have no outputs (all yields are empty).
            </summary>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Compose(Microsoft.Automata.ST{`0,`1,`2},Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Composes A with B, the result is A+B such that A+B(s) = B(A(s)) for all s.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.RestrictDomain(System.String)">
            <summary>
            Restrict the domain of the ST with respect to the given regex.
            </summary>
            <param name="regex">defines the domain restriction</param>
            <returns>ST that accepts input lists also accepted by the regex</returns>
        </member>
        <member name="M:Microsoft.Automata.ST`3.RestrictDomain(Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Restrict the domain of the ST with respect to the given SFA.
            </summary>
            <param name="sfa">defines the domain restriction</param>
            <returns>ST that accepts input lists also accepted by the SFA</returns>
        </member>
        <member name="M:Microsoft.Automata.ST`3.RemoveYields">
            <summary>
            Replaces all outputs by empty outputs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.SFAtoST(Microsoft.Automata.SFA{`0,`1,`2})">
            <summary>
            Lift the sfa into an ST with initial register sfa.Solver.UnitConst, and register and output sort sfa.Solver.UnitSort.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.RegisterVar">
            <summary>
            Register variable is Solver.MkVar(1, RegisterSort).
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.InputVar">
            <summary>
            Input variable is Solver.MkVar(0, InputSort).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.ExploreFull">
            <summary>
            inernal version that works correctly with a product construction
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.ExploreBools">
            <summary>
            Computes an equivalent ST by exploring all the Boolean register components, preserves all nonBoolean register components as symbolic.
            Is equivalent to Explore() when all register components are Boolean.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.ExploreAndGroup">
            <summary>
            Explore and group. Returns an equivalent (up to grouping) SFT.
            The result is multi-output if this ST is multi-output.
            Assumes that this ST has been lifted.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Explore">
            <summary>
            Computes an equivalent finite state symbolic transducer (if one exists) by exploring the registers using DFS.
            The computation does not terminate when the number of resulting states is infinite.
            The resulting ST does not use registers and therefore has register sort Solver.UnitSort, 
            initial register is Solver.UnitConst, and all (nonfinal) rules have register update Solver.UnitConst.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Explore(System.Int32)">
            <summary>
            Explore for max nr of inputs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.ExploreAlgo(System.Boolean,System.Int32)">
            <summary>
            Main exploration algo
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.ToSFA">
            <summary>
            Extract the domain as an SFA.
            Returns null when an SFA conversion is not possible in the case of multi-input STs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.ToIdOutput">
            <summary>
            Converts all yields to just output the given input.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.IsFinalRule(Microsoft.Automata.Rule{`1})">
            <summary>
            Returns rule.IsFinal
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Diff(Microsoft.Automata.ST{`0,`1,`2},System.Int32)">
            <summary>
            Returns null if this ST and the second ST produce the same outputs for all inputs up to the given maximum length.
            Otherwise returns a counterexample to 1-equality of this ST and the second ST.
            </summary>
            <param name="st">the second ST</param>
            <param name="maxInputLength">maximum bound for the input sequences to be considered</param>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Diff(Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Returns a counterexample to 1-equality of this ST and the second ST.
            When the STs are 1-equivalent, Diff may not terminate or returns null.
            Note: this.Diff(this) returns a counterexample iff this ST is not single-valued.
            </summary>
            <param name="st">the second ST</param>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Eq1(Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Returns false iff this and B are not 1-equal, i.e., 
            if there exists u,v,w s.t. this(u,v) and B(u,w) but v!=w.
            Note that this.Eq1(this)=false iff this is not single-valued.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Eq1(Microsoft.Automata.ST{`0,`1,`2},Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Returns false iff A and B are not 1-equal, i.e., 
            if there exists u,v,w s.t. A(u,v) and B(u,w) but v!=w.
            Note that Eq1(A,A)=false iff A is not single-valued.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Neq1(Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Returns null if this ST and the other ST are 1-equal, returns a conterexample otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Neq1(Microsoft.Automata.ST{`0,`1,`2},Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Returns null if A and B are 1-equal, returns a counterexample otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.AddEOI">
            <summary>
            Lift the inputsort to Option(inputsort), None is used exclusively as the EOI symbol.
            All valid inputs terminate with None.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.IsMultiInput">
            <summary>
            Returns true iff the ST uses multiple input characters rules. In this case the input character is a list sort.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Apply(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Applies the concrete input to produce the concrete output.
            </summary>
            <param name="input">concrete input</param>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Apply2(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Applies the concrete input to produce the secondary concrete output in case of a product ST.
            </summary>
            <param name="input">concrete input</param>
        </member>
        <member name="M:Microsoft.Automata.ST`3.LiftIputSortToList">
            <summary>
            Given a product ST, lift the input character sort s to the sort List(s). 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.EliminateIntermediateStates">
            <summary>
            Eliminate intermediate states. Assumes lifted input and possibly product ST.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.DeleteRegister">
            <summary>
            Returns the equivalent SFT by deleting the register if all moves are register-independent. Returns null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Eq1_v2(Microsoft.Automata.ST{`0,`1,`2},Microsoft.Automata.ST{`0,`1,`2})">
            <summary>
            Returns false iff A and B are not 1-equal, i.e., 
            if there exists u,v,w s.t. A(u,v) and B(u,w) but v!=w.
            Note that Eq1(A,A)=false iff A is not single-valued.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.ST`3.ExploreFrom(System.Int32,`1)">
            <summary>
            Enumerates incrementally all moves from the given start state and concrete start register value.
            Yields and guards of all rules are concretized with the given start register value.
            The update of a nonfinal rule is a resulting concrete register value
            and the guard restricts the input with respect to that resulting register value.
            </summary>
            <param name="state">given start state</param>
            <param name="reg">given concrete start register value</param>
            <returns>all possible moves with concrete register instantiations</returns>
        </member>
        <member name="M:Microsoft.Automata.ST`3.Simplify">
            <summary>
            Replaces terms by logically equivalent simpler terms in the ST.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ST`3.CounterExample">
            <summary>
            Provides a counterexample to 1-equality between STs returned by the ST.Diff method.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.CounterExample.InputLength">
            <summary>
            Length of the input sequece of the counterexample.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.CounterExample.Input">
            <summary>
            Input sequence that is a counterexample to 1-equality.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.CounterExample.Output1">
            <summary>
            Output sequence from the first ST for the given input.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ST`3.CounterExample.Output2">
            <summary>
            Output sequence from the second ST for the given input.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ICounterexample`1">
            <summary>
            Provides a counterexample to 1-equality between STs returned by the ST.Diff method.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICounterexample`1.InputLength">
            <summary>
            Length of the input sequece of the counterexample.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICounterexample`1.Input">
            <summary>
            Input sequence that is a counterexample to 1-equality.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICounterexample`1.Output1">
            <summary>
            Output sequence from the first ST for the given input.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ICounterexample`1.Output2">
            <summary>
            Output sequence from the second ST for the given input.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ISTb`1">
            <summary>
            Interface to deterministic symbolic transducers with branching rules.
            </summary>
            <typeparam name="TERM">type of terms</typeparam>
        </member>
        <member name="M:Microsoft.Automata.ISTb`1.GetRuleFrom(System.Int32)">
            <summary>
            Get the nonfinal rule from the given state.
            </summary>
            <param name="state">given start state</param>
        </member>
        <member name="M:Microsoft.Automata.ISTb`1.GetFinalRuleFrom(System.Int32)">
            <summary>
            Get the final rule from the given state.
            </summary>
            <param name="state">given start state</param>
        </member>
        <member name="P:Microsoft.Automata.ISTb`1.InitialState">
            <summary>
            Gets the initial state.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.ISTb`1.States">
            <summary>
            List of all the states. 
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IRegisterInfo`1">
            <summary>
            Interface for checking a predicate over register updates.
            </summary>
            <typeparam name="TERM">type of terms</typeparam>
        </member>
        <member name="M:Microsoft.Automata.IRegisterInfo`1.IsTrueForAllRegisterUpdates(System.Predicate{`0})">
            <summary>
            Returns true iff the predicate holds for all register update terms.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IRegisterInfo`1.InitialRegister">
            <summary>
            Gets the initial register.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.STb`3">
            <summary>
            Symbolic Transducer with branching rules.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.STb`3.ST">
            <summary>
            Gets or sets the underlying ST, or null if it does not exist.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.STb`3.Solver">
            <summary>
            The associated SMT solver.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.AssignRule(System.Int32,Microsoft.Automata.BranchingRule{`1})">
            <summary>
            Assigns the rule to the given state. Overwrites any previously assigned rule.
            </summary>
            <param name="state">start state</param>
            <param name="rule">the rule that applies from the given state</param>
        </member>
        <member name="M:Microsoft.Automata.STb`3.AssignFinalRule(System.Int32,Microsoft.Automata.BranchingRule{`1})">
            <summary>
            Assigns the final rule to the given state. Overwrites any previously assigned rule.
            </summary>
            <param name="state">start state</param>
            <param name="rule">the final rule that applies from the given state</param>
        </member>
        <member name="M:Microsoft.Automata.STb`3.IsFinalState(System.Int32)">
            <summary>
            Returns true iff the given state is associated with a final rule.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.GetRuleFrom(System.Int32)">
            <summary>
            Gets the nonfinal rule assigned to the given start state. 
            </summary>
            <param name="state">given start state</param>
        </member>
        <member name="M:Microsoft.Automata.STb`3.GetFinalRuleFrom(System.Int32)">
            <summary>
            Gets the final rule assigned to the given start state. 
            </summary>
            <param name="state">given start state</param>
        </member>
        <member name="P:Microsoft.Automata.STb`3.InitialState">
            <summary>
            Gets the initial state.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.STb`3.InitialRegister">
            <summary>
            Gets the initial register.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToST_orig">
            <summary>
            Convert the STb to an equivalent ST by flattening the branching rules to individual moves.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToST(System.Boolean)">
            <summary>
            Convert the STb to an equivalent ST by flattening the branching rules to individual moves.
            The original state ids are preserved.
            Omits yields if omitYields is true.
            </summary>
            <param name="omitYields">if true, omit all yields from the generated ST, otherwise preserve the yields</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ShowGraph">
            <summary>
            Saves the STb in dgml format in Name.dgml file in the working directory and starts a process for viewing the file.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ShowGraph(System.Int32)">
            <summary>
            Saves the STb in dgml format in Name.dgml file in the working directory and starts a process for viewing the file.
            Restricts the edge labels to at most k characters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToDgml">
            <summary>
            Saves the STb in dgml format in Name.dgml file in the working directory.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToDgml(System.Int32)">
            <summary>
            Saves the STb in dgml format in Name.dgml file in the working directory.
            Restricts the edge labels to at most k characters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToDot">
            <summary>
            Saves the STb in dot format in <name>Name</name>.dot file in the working directory.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToDot(System.String)">
            <summary>
            Saves the STb in dot format in the given file (adds the suffix '.dot' when mssing) in the working directory.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToDot(System.IO.TextWriter)">
            <summary>
            Saves the STb in dot format using the given text writer.
            </summary> 
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToDot(System.Int32)">
            <summary>
            Saves the STb in dot format in <name>Name</name>.dot file in the working directory.
            Restricts the edge labels to at most k characters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToDot(System.Int32,System.String)">
            <summary>
            Saves the STb in dot format in the given file (adds the suffix '.dot' when mssing) in the working directory.
            Restricts the edge labels to at most k characters.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToDot(System.Int32,System.IO.TextWriter)">
            <summary>
            Saves the STb in dot format using the given text writer.
            Restricts the edge labels to at most k characters.
            </summary> 
        </member>
        <member name="M:Microsoft.Automata.STb`3.Explore">
            <summary>
            Computes an equivalent finite state symbolic transducer (if one exists) by exploring the registers using DFS.
            The computation does not terminate when the number of resulting states is infinite.
            The resulting ST does not use registers and therefore has register sort Solver.UnitSort, 
            initial register is Solver.UnitConst, and all (nonfinal) rules have register update Solver.UnitConst.
            The exploration preserves the branching structure.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ExploreBools">
            <summary>
            Computes an equivalent STb by exploring all the Boolean and fixed-valued register components, 
            preserves all nonBoolean and non-fixed-valued register components as symbolic.
            Is equivalent to Explore() when all register components are Boolean or fixed-valued.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ExploreAlgo(System.Boolean)">
            <summary>
            Main exploration algo, useBP also implies that fixed-valued register components are explored.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToBek(System.IO.TextWriter)">
            <summary>
            Converts the STb to a textual representation as a Bek program.
            Writes the text to the given text writer tw.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToBek(System.String)">
            <summary>
            Converts the STb to a textual representation as a Bek program.
            Saves the resulting bek program in the given file.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToBek(System.Text.StringBuilder)">
            <summary>
            Converts the STb to a textual representation as a Bek program.
            Writes the text to the given string builder sb.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToCS(System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Generates code for the transducer as a static CSharp method &lt;namespacename&gt;.&lt;classname&gt;.Apply.
            </summary>
            <param name="file">generated code is written to this file</param>
            <param name="namespacename">if null or empty then "tmp" is used</param>
            <param name="classname">if null or empty then the name of the transducer is used</param>
            <param name="generateSFT">if true and registers are not used then generate methods for finite state streaming of input to output</param>
            <param name="useArray">if true then generates code using Array instead of StringBuilder and generateSFT option is then ignored</param>
            <param name="returnNullOnReject">if true then if the input is rejected then null is returned instead of exception being thrown</param>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToCS(System.Action{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Generates code for the transducer as a static CSharp method &lt;namespacename&gt;.&lt;classname&gt;.Apply.
            </summary>
            <param name="WriteLine">generated code is written by invoking this action</param>
            <param name="namespacename">if null or empty then "tmp" is used</param>
            <param name="classname">if null or empty then the name of the transducer is used</param>
            <param name="generateSFT">if true and registers are not used then generate methods for finite state streaming of input to output</param>
            <param name="useArray">if true then generates code using Array instead of StringBuilder and generateSFT option is then ignored</param>
            <param name="returnNullOnReject">if true then if the input is rejected then null is returned instead of exception being thrown</param>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToC(System.String)">
            <summary>
            Generate C code.
            </summary>
            <param name="file">target file of the generated code</param>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToC(System.Action{System.String})">
            <summary>
            Generate C code.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToJS(System.String,System.Boolean,System.String)">
            <summary>
            Generate JavaScript.
            </summary>
            <param name="file">file where the generated code is written</param>
            <param name="addHtmlPageWrapper">if true create a simple html wrapper around the code so it can be executed in a browser</param>
            <param name="methodname">name for the generated method</param>
        </member>
        <member name="M:Microsoft.Automata.STb`3.ToJS(System.Action{System.String},System.Boolean,System.String)">
            <summary>
            Generate JavaScript.
            </summary>
            <param name="WriteLine">assumed to be the output fuction</param>
            <param name="addHtmlPageWrapper">if true create a simple html wrapper around the code so it can be executed in a browser</param>
            <param name="methodname">name for the generated method</param>
        </member>
        <member name="M:Microsoft.Automata.STb`3.IsTrueForAllRegisterUpdates(System.Predicate{`1})">
            <summary>
            Returns true iff pred holds for all register update terms.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STb`3.Compile(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generate C# and compile the generated C#.
            </summary>
            <param name="namespacename">given namespace name</param>
            <param name="classname">given class name</param>
            <param name="useArray">use Array instead of StringBuilder internally</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.STb`3.EliminateDeadends">
            <summary>
            Eliminate all states that do not lead to some final state.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.IExecutableTransducer">
            <summary>
            Provides methods to execute a string transducer.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.IExecutableTransducer.Apply(System.String)">
            <summary>
            Applies the string transducer to the given input string.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.IExecutableTransducer.Source">
            <summary>
            Gets the compiled source code.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.ParseType">
            <summary></summary>
        </member>
        <member name="F:Microsoft.Automata.ParseType.Boolean">
            <summary></summary>
        </member>
        <member name="F:Microsoft.Automata.ParseType.Int32">
            <summary></summary>
        </member>
        <member name="F:Microsoft.Automata.ParseType.String">
            <summary></summary>
        </member>
        <member name="F:Microsoft.Automata.ParseType.Skip">
            <summary></summary>
        </member>
        <member name="T:Microsoft.Automata.STBuilder`3">
            <summary>
            Builder for Symbolic Transducers that uses a given solver.
            The builder provides some convenience functions.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.STBuilder`3.Solver">
            <summary>
            Gets the underlying solver of the ST builder.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.#ctor(Microsoft.Automata.IContext{`0,`1,`2})">
            <summary>
            Create a new ST builder with the given solver.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkST(System.String,`1,`2,`2,`2,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.Automata.Move{Microsoft.Automata.Rule{`1}}})">
            <summary>
            Create an ST with the given solver. Calls ST.Create(solver,...)
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkIdentityST(`2)">
            <summary>
            Make the ST that is the identity function from input sequences to output sequences.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkRule(System.Int32,System.Int32,`1,`1,`1[])">
            <summary>
            Make a move that corresponds to a nonfinal rule. This is indicated by IsFinal=false of the label of the move.
            </summary>
            <param name="source">source state of the move</param>
            <param name="target">target state of the move</param>
            <param name="guard">guard of the rule</param>
            <param name="update">update of the rule</param>
            <param name="yields">sequence of output yields of the rule</param>
            <returns>nonfinal move from source to target</returns>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkFinalOutput(System.Int32,`1,`1[])">
            <summary>
             Make a move that corresponds to a final rule. This is indicated by IsFinal=true of the condition of the move.
            </summary>
            <param name="finalState">final state</param>
            <param name="finalCondition">guard of the final outputs</param>
            <param name="finalYields">final outputs</param>
            <returns>a move from final state to final state that represents the final outputs yielded from the final state</returns>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkInputVariable(`2)">
            <summary>
            The input variable for the given sort. The variable has index 0.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkRegister(`2)">
            <summary>
            The register variable for the given sort. The variable has index 1.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.CreateFromRegex(System.String,System.String)">
            <summary>
            Creates an SFA from the given regex, with the character sort solver.CharSort.
            </summary>
            <param name="name">name of the SFA</param>
            <param name="regex">the regex from which the SFA is created</param>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.Not(`1)">
            <summary>
            Negates the predicate, provides trivial optimizations: Not(False)= True and Not(True) = False.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.And(`1,`1)">
            <summary>
            Conjunction of the predicates, provides trivial optimization such as And(True, P) = P, etc.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.Or(`1,`1)">
            <summary>
            Disjunction of the predicates, provides trivial optimization such as Or(False, P) = P, etc.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkBPInstance(`1,`1,`1)">
            <summary>
            For example, given reg: (bool x int x bool x int), b : (bool x bool), newreg : (int x int).
            Returns T(b.0, newreg.0, b.1, newreg.1)
            </summary> 
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkTupleSkeleton(`1)">
            <summary>
            For example if r is a variable of sort s0 x (s10 x s11) makes the term T(r.0, T(r.1.0, r.1.1))
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.MkTupleVarSkeleton(`1,System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{`1,`1}}@)">
            <summary>
            For example if s is a sort (s0 x (s10 x s11)) makes the term T(#2, T(#3, #4))
            and the output dictionary  #2 -> r.0, #3 -> r.1.0, #4 -> r.1.1
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.GetProjectionPair(Microsoft.Automata.IRegisterInfo{`1},`1@,`1@,System.Func{`1,`1,`1}@)">
            <summary>
            Get the projection pair for A, the control-state projection, and the register-state projection.
            Gets also the function combine that combines the projections back to the original register format 
            combine(control_state,register_state).
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.BP(`1)">
            <summary>
            Boolean Projection
            </summary>
        </member>
        <member name="M:Microsoft.Automata.STBuilder`3.NBP(`1)">
            <summary>
            Non-Boolean Projection
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegexBuilder`1">
            <summary>
            Builder of symbolic regexes over S. 
            S is the type of elements of an effective Boolean algebra.
            Used to convert .NET regexes to symbolic regexes.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.#ctor(Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Create a new symbolic regex builder.
            </summary>
            <param name="solver">Effective Boolean algebra over S.</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.InitilizeFields(Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Initializer all fields, used also by deserializer of SymbolicRegexMatcher
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkOr(Microsoft.Automata.SymbolicRegexNode{`0}[])">
            <summary>
            Make a disjunction of given regexes, simplify by eliminating any regex that accepts no inputs
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkAnd(Microsoft.Automata.SymbolicRegexNode{`0}[])">
            <summary>
            Make a conjunction of given regexes, simplify by eliminating regexes that accept everything
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkOr(Microsoft.Automata.SymbolicRegexSet{`0})">
            <summary>
            Make a disjunction of given regexes, simplify by eliminating any regex that accepts no inputs
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkAnd(Microsoft.Automata.SymbolicRegexSet{`0})">
            <summary>
            Make a conjunction of given regexes, simplify by eliminating any regex that accepts all inputs, 
            returns the empty regex if the regex accepts nothing
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkConcat(Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.SymbolicRegexNode{`0})">
            <summary>
            Make a concatenation of given regexes, if any regex is nothing then return nothing, eliminate 
            intermediate epsilons
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkConcat(Microsoft.Automata.SymbolicRegexNode{`0}[],System.Boolean)">
            <summary>
            Make a concatenation of given regexes, if any regex is nothing then return nothing, eliminate 
            intermediate epsilons, if toplevel, add watchdog at the end
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkLoop(Microsoft.Automata.SymbolicRegexNode{`0},System.Boolean,System.Int32,System.Int32)">
            <summary>
            Make loop regex
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkSingleton(`0)">
            <summary>
            Make a singleton sequence regex
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkWatchDog(System.Int32)">
            <summary>
            Make end of sequence marker
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkSequence(`0[],System.Boolean)">
            <summary>
            Make a sequence regex, i.e., a concatenation of singletons, with a watchdog at the end
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.MkIfThenElse(Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.SymbolicRegexNode{`0})">
            <summary>
            Make an if-then-else regex (?(cond)left|right), 
            or create it as conjuction if right is false
            </summary>
            <param name="cond">condition</param>
            <param name="left">true case</param>
            <param name="right">false case</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.RemoveAnchors(Microsoft.Automata.SymbolicRegexNode{`0},System.Boolean,System.Boolean)">
            <summary>
            Goes over the symbolic regex, removes anchors, adds .* if anchors were not present. 
            Creates an equivalent regex with implicit start and end anchors.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexBuilder`1.Deserialize(System.String)">
            <summary>
            Deserialize a symbolic regex from its serialized representation 
            that was produced by SymbolicRegexNode.Serialize
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegexBV">
            <summary>
            Wraps an instance of SymbolicRegex&lt;BV&gt;, the number of needed partition blocks is &gt; 64
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.Automata.SymbolicRegexBV.#ctor(Microsoft.Automata.SymbolicRegexNode{Microsoft.Automata.BDD},Microsoft.Automata.CharSetSolver,Microsoft.Automata.BDD[],System.Int32,System.Int32)" -->
        <member name="M:Microsoft.Automata.SymbolicRegexBV.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Invoked by deserializer
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegexUInt64">
            <summary>
            Wraps an instance of SymbolicRegex&lt;ulong&gt;, the number of needed partition blocks is &lt; 65
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexUInt64.#ctor(Microsoft.Automata.SymbolicRegexNode{Microsoft.Automata.BDD},Microsoft.Automata.CharSetSolver,Microsoft.Automata.BDD[],System.Int32,System.Int32)">
            <summary>
            Is called with minterms.Length at most 64
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexUInt64.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Invoked by deserializer
            </summary>
        </member>
        <member name="T:Microsoft.Automata.RegexMatcher">
            <summary>
            Base class for regex matchers
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexMatcher.GenerateRandomMatch(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generate a random string that is a complete match.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexMatcher.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Extends System.Runtime.Serialization.ISerializable
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexMatcher.IsMatch(System.String,System.Int32,System.Int32)">
            <summary>
            Returns true iff the input string matches. 
            <param name="input">given iput string</param>
            <param name="startat">start position in the input</param>
            <param name="endat">end position in the input, -1 means that the value is unspecified and taken to be input.Length-1</param>
            </summary>
        </member>
        <member name="M:Microsoft.Automata.RegexMatcher.Matches(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns all matches as pairs (startindex, length) in the input string.
            </summary>
            <param name="input">given iput string</param>
            <param name="limit">as soon as this many matches have been found the search terminates, 0 or negative value means that there is no bound, default is 0</param>
            <param name="startat">start position in the input, default is 0</param>
            <param name="endat">end position in the input, -1 means that the value is unspecified and taken to be input.Length-1</param>
        </member>
        <member name="M:Microsoft.Automata.RegexMatcher.Serialize(System.IO.Stream,System.Runtime.Serialization.IFormatter)">
            <summary>
            Serialize this symbolic regex matcher to the given stream.
            If formatter is null then an instance of 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter is used.
            </summary>
            <param name="stream">stream where the serialization is stored</param>
            <param name="formatter">given formatter</param>
        </member>
        <member name="M:Microsoft.Automata.RegexMatcher.Serialize(System.String,System.Runtime.Serialization.IFormatter)">
            <summary>
            Serialize this symbolic regex matcher to the given file.
            If formatter is null then an instance of 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter is used.
            </summary>
            <param name="file">file where the serialization is stored</param>
            <param name="formatter">given formatter</param>
        </member>
        <member name="M:Microsoft.Automata.RegexMatcher.Deserialize(System.String,System.Runtime.Serialization.IFormatter)">
            <summary>
            Deserialize the matcher of a symblic regex from the given file using the given formatter. 
            If formatter is null then an instance of 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter is used.
            </summary>
            <param name="file">source file of the serialized matcher</param>
            <param name="formatter">given formatter</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.RegexMatcher.Deserialize(System.IO.Stream,System.Runtime.Serialization.IFormatter)">
            <summary>
            Deserialize the matcher of a symblic regex from the given stream using the given formatter. 
            If formatter is null then an instance of 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter is used.
            </summary>
            <param name="stream">source stream of the serialized matcher</param>
            <param name="formatter">given formatter</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.FixedStringMatcher">
            <summary>
            Represents a precompiled match generator for a fixed Unicode string
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegex`1">
            <summary>
            Represents a precompiled form of a regex that implements match generation using symbolic derivatives.
            </summary>
            <typeparam name="S">character set type</typeparam>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.atoms">
            <summary>
            Partition of the input space of predicates.
            Length of atoms is K.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.dt">
            <summary>
            Maps each character into a partition id in the range 0..K-1.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.q0_A2">
            <summary>
            Used only by IsMatch and if A2 is used.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.q0_A1">
            <summary>
            Initial state of A1 (0 is not used).
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.q0_Ar">
            <summary>
            Initial state of Ar (0 is not used).
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.q0_A">
            <summary>
            Initial state of A (0 is not used).
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.nextStateId">
            <summary>
            Next available state id.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_StartSet_Vec">
            <summary>
            If not null then contains all relevant start characters as vectors
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_StartSet_singleton">
            <summary>
            If A_StartSet_Vec is length 1 then contains the corresponding character
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_prefixUTF8_first_byte">
            <summary>
            First byte of A_prefixUTF8 in vector
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A">
            <summary>
            Original regex.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegex`1.Pattern">
            <summary>
            Main pattern of the matcher
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegex`1.ReversePattern">
            <summary>
            Reverse pattern of the matcher
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegex`1.DotStarPattern">
            <summary>
            Dot star in front of the pattern of the matcher
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_StartSet">
            <summary>
            Set of elements that matter as first element of A. 
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_StartSet_compiled">
            <summary>
            A vectorized decision stree evaluator generated and compiled from  A_StartSet. 
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_startset">
            <summary>
            predicate over characters that make some progress
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_StartSet_Size">
            <summary>
            Number of elements in A_StartSet
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_prefix">
            <summary>
            if nonempty then A has that fixed prefix
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_prefixUTF8">
            <summary>
            if nonempty then A has that fixed prefix
            </summary>>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_prefix_array">
            <summary>
            predicate array corresponding to fixed prefix of A
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A_fixedPrefix_ignoreCase">
            <summary>
            if true then the fixed prefix of A is idependent of case
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A1_skipState">
            <summary>
            precomputed state of A1 that is reached after the fixed prefix of A
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A1_skipStateRegex">
            <summary>
            precomputed regex of A1 that is reached after the fixed prefix of A
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.Ar">
            <summary>
            Reverse(A).
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.Ar_prefix_array">
            <summary>
            if nonempty then Ar has that fixed prefix of predicates
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.Ar_skipState">
            <summary>
            precomputed state that is reached after the fixed prefix of Ar
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.Ar_skipStateRegex">
            <summary>
            precomputed regex that is reached after the fixed prefix of Ar
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A1">
            <summary>
            .*A
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.A2">
            <summary>
            Variant of A1 for matching.
            In A2 anchors have been removed. 
            Used only by IsMatch and when A contains anchors.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.K">
            <summary>
            Initialized to atoms.Length.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.regex2state">
            <summary>
            Maps regexes to state ids
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.state2regexExtra">
            <summary>
            Maps states >= StateLimit to regexes.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.state2regex">
            <summary>
            Maps states 1..(StateLimit-1) to regexes. 
            State 0 is not used but is reserved for denoting UNDEFINED value.
            Length of state2regex is StateLimit. Entry 0 is not used.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.deltaExtra">
            <summary>
            Overflow from delta. Transitions with source state over the limit.
            Each entry (q, [p_0...p_n]) has n = atoms.Length-1 and represents the transitions q --atoms[i]--> p_i.
            All defined states are strictly positive, p_i==0 means that q --atoms[i]--> p_i is still undefined.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.StateLimit">
            <summary>
            Bound on the maximum nr of states stored in array.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.StartSetSizeLimit">
            <summary>
            Bound on the maximum nr of chars that trigger vectorized IndexOf.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegex`1.delta">
            <summary>
            Holds all transitions for states 1..MaxNrOfStates-1.
            each transition q ---atoms[i]---> p is represented by entry p = delta[(q * K) + i]. 
            Length of delta is K*StateLimit.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            This serialization method is invoked by BinaryFormatter.Serialize via Serialize method.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            This deserialization constructor is invoked by IFormatter.Deserialize via Deserialize method
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.Serialize(System.String,System.Runtime.Serialization.IFormatter)">
            <summary>
            Serialize this symbolic regex matcher to the given file.
            If formatter is null then an instance of 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter is used.
            </summary>
            <param name="file">file where the serialization is stored</param>
            <param name="formatter">given formatter</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.SerializeSimplified(System.IO.Stream,System.Runtime.Serialization.IFormatter)">
            <summary>
            Simplified serialization, character classes are replaced by some singletons.
            Used for testing purposes only.
            </summary>
            <param name="stream">stream where the serialization is stored</param>
            <param name="formatter">given formatter</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.Serialize(System.IO.Stream,System.Runtime.Serialization.IFormatter)">
            <summary>
            Serialize this symbolic regex matcher to the given file.
            If formatter is null then an instance of 
            System.Runtime.Serialization.Formatters.Binary.BinaryFormatter is used.
            </summary>
            <param name="stream">stream where the serialization is stored</param>
            <param name="formatter">given formatter</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.Parse(System.String)">
            <summary>
            Parse a symbolic regex from its serialized form.
            </summary>
            <param name="symbolicregex">serialized form of a symbolic regex</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.#ctor(Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.CharSetSolver,Microsoft.Automata.BDD[],System.Int32,System.Int32)">
            <summary>
            Constructs matcher for given symbolic regex
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.DeltaPlus(System.String,System.Int32,Microsoft.Automata.SymbolicRegexNode{`0}@)">
            <summary>
            Return the state after the given input.
            </summary>
            <param name="input">given input</param>
            <param name="q">given start state</param>
            <param name="regex">regex of returned state</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.Delta(System.Int32,System.Int32,Microsoft.Automata.SymbolicRegexNode{`0}@)">
            <summary>
            Compute the target state for source state q and input character c.
            All uses of Delta must be inlined for efficiency. 
            This is the purpose of the MethodImpl(MethodImplOptions.AggressiveInlining) attribute.
            </summary>
            <param name="c">input character</param>
            <param name="q">state id of source regex</param>
            <param name="regex">target regex</param>
            <returns>state id of target regex</returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.CreateNewTransitionExtra(System.Int32,System.Int32,`0,System.Int32[],System.Int32@,Microsoft.Automata.SymbolicRegexNode{`0}@)">
            <summary>
            Critical region for threadsafe applications for defining a new transition from q when q is larger that StateLimit
            </summary>
            
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.CreateNewTransition(System.Int32,`0,System.Int32,System.Int32@,Microsoft.Automata.SymbolicRegexNode{`0}@)">
            <summary>
            Critical region for threadsafe applications for defining a new transition
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.Matches(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generate all matches.
            <param name="input">input string</param>
            <param name="limit">upper bound on the number of found matches, nonpositive value (default is 0) means no bound</param>
            <param name="startat">the position to start search in the input string</param>
            <param name="endat">end position in the input, negative value means unspecified and taken to be input.Length-1</param>
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.GetWatchdog(Microsoft.Automata.SymbolicRegexNode{`0})">
            <summary>
            It is known here that regex is nullable
            </summary>
            <param name="regex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.IsMatch(System.String,System.Int32@,System.Int32@,System.Int32,System.Int32)">
            <summary>
            Returns true iff the input string matches A.
            <param name="input">input string</param>
            <param name="startat">the position to start search in the input string</param>
            <param name="endat">end position in the input, negative value means 
            unspecified and taken to be input.Length-1</param>
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.IsMatchCA(System.String,Microsoft.Automata.CsAutomatonOpt{`0},System.Boolean,Microsoft.Automata.CSMatcher,System.Int32)">
            <summary>
            Returns true iff the input string matches A.
            <param name="input">input string</param>
            <param name="startat">the position to start search in the input string</param>
            <param name="endat">end position in the input, negative value means 
            unspecified and taken to be input.Length-1</param>
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindEndPosition(System.String,System.Int32)">
            <summary>
            Find match end position using A, end position is known to exist.
            </summary>
            <param name="input">input array</param>
            <param name="i">start position</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindStartPosition(System.String,System.Int32,System.Int32)">
            <summary>
            Walk back in reverse using Ar to find the start position of match, start position is known to exist.
            </summary>
            <param name="input">the input string</param>
            <param name="i">position to start walking back from, i points at the last character of the match</param>
            <param name="match_start_boundary">do not pass this boundary when walking back</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindFinalStatePosition(System.String,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Return the position of the last character that leads to a final state in A1
            </summary>
            <param name="input">given input string</param>
            <param name="i">start position</param>
            <param name="i_q0">last position the initial state of A1 was visited</param>
            <param name="k">input length or bounded input length</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindFinalStatePositionCA(System.String,Microsoft.Automata.CsAutomatonOpt{`0},System.Int32,System.Int32,System.Boolean,Microsoft.Automata.CSMatcher)">
            <summary>
            Return the position of the last character that leads to a final state in A1
            </summary>
            <param name="input">given input string</param>
            <param name="i">start position</param>
            <param name="i_q0">last position the initial state of A1 was visited</param>
            <param name="k">input length or bounded input length</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindFinalStatePositionCAOpt(System.String,Microsoft.Automata.CsAutomatonOpt{`0},System.Int32,System.Int32)">
            <summary>
            FindFinalState optimized for the case when A starts with a fixed prefix
            </summary>
            <param name="input">given input string</param>
            <param name="i">start position</param>
            <param name="i_q0">last position the initial state of A1 was visited</param>
            <param name="k">input length or bounded input length</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindFinalStatePositionOpt(System.String,System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            FindFinalState optimized for the case when A starts with a fixed prefix
            </summary>
            <param name="input">given input string</param>
            <param name="i">start position</param>
            <param name="i_q0">last position the initial state of A1 was visited</param>
            <param name="k">input length or bounded input length</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.Matches_(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generate all earliest maximal matches. We know that k is at least 2. Unsafe version of Matches.
            <param name="input">pointer to input string</param>
            <param name="limit">upper bound on the number of found matches, nonpositive value (default is 0) means no bound</param>
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindFinalStatePosition_(System.Char*,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Return the position of the last character that leads to a final state in A1
            </summary>
            <param name="inputp">given input string</param>
            <param name="k">length of input</param>
            <param name="i">start position</param>
            <param name="i_q0">last position the initial state of A1 was visited</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindFinalStatePositionOpt_(System.String,System.Int32,System.Int32@)">
            <summary>
            FindFinalState optimized for the case when A starts with a fixed prefix and does not ignore case
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindStartPosition_(System.Char*,System.Int32,System.Int32)">
            <summary>
            Walk back in reverse using Ar to find the start position of match, start position is known to exist.
            </summary>
            <param name="input">the input array</param>
            <param name="i">position to start walking back from, i points at the last character of the match</param>
            <param name="match_start_boundary">do not pass this boundary when walking back</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindEndPosition_(System.Char*,System.Int32,System.Int32)">
            <summary>
            Find match end position using A, end position is known to exist.
            </summary>
            <param name="input">input array</param>
            <param name="k">length of input</param>
            <param name="i">start position</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.IndexOfStartset(System.String,System.Int32)">
            <summary>
             Find first occurrence of startset element in input starting from index i.
            </summary>
            <param name="input">input string to search in</param>
            <param name="i">the start index in input to search from</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.IndexOfStartsetUTF8(System.Byte[],System.Int32,System.Int32@)">
            <summary>
             Find first occurrence of startset element in input starting from index i.
            </summary>
            <param name="input">input string to search in</param>
            <param name="i">the start index in input to search from</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.IndexOfStartset_(System.Char*,System.Int32,System.Int32)">
            <summary>
             Find first occurrence of startset element in input starting from index i.
            </summary>
            <param name="input">input string to search in</param>
            <param name="k">length of the input</param>
            <param name="i">the start index in input to search from</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.IndexOf(System.Byte[],System.Byte[],System.Int32)">
            <summary>
             Find first occurrence of value in input starting from index i.
            </summary>
            <param name="input">input array to search in</param>
            <param name="value">nonempty subarray that is searched for</param>
            <param name="i">the search start index in input</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.IndexOf(System.Byte[],System.Boolean[],System.Int32)">
            <summary>
             Find first occurrence of byte in input starting from index i that maps to true by the predicate.
            </summary>
            <param name="input">input array to search in</param>
            <param name="pred">boolean array of size 256 telling which bytes to match</param>
            <param name="i">the search start index in input</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.IndexOfStartPrefix_(System.Char*,System.Int32,System.Int32)">
            <summary>
             Find first occurrence of s in input starting from index i.
             This method is called when A has nonemmpty prefix and ingorecase is false
            </summary>
            <param name="input">input string to search in</param>
            <param name="k">length of input string</param>
            <param name="i">the start index in input</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.MatchesUTF8(System.Byte[])">
            <summary>
            Generate all earliest maximal matches.
            <paramref name="input">pointer to input string</paramref>
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindEndPositionUTF8(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Find match end position using A, end position is known to exist.
            </summary>
            <param name="input">input array</param>
            <param name="i">start position</param>
            <param name="surrogate_codepoint">surrogate codepoint</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindStartPositionUTF8(System.Byte[],System.Int32,System.Int32@,System.Int32)">
            <summary>
            Walk back in reverse using Ar to find the start position of match, start position is known to exist.
            </summary>
            <param name="input">the input array</param>
            <param name="i">position to start walking back from, i points at the last character of the match</param>
            <param name="match_start_boundary">do not pass this boundary when walking back</param>
            <param name="surrogate_codepoint">surrogate codepoint</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegex`1.FindFinalStatePositionUTF8(System.Byte[],System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Return the position of the last character that leads to a final state in A1
            </summary>
            <param name="input">given input array</param>
            <param name="i">start position</param>
            <param name="i_q0">last position the initial state of A1 was visited</param>
            <param name="surrogate_codepoint">surrogate codepoint</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegexKind">
            <summary>
            Kinds of symbolic regexes
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegexNode`1">
            <summary>
            Represents an AST node of a symbolic regex.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.Serialize">
            <summary>
            Produce the serialized from of this symbolic regex node.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.Serialize(Microsoft.Automata.SymbolicRegexNode{`0},System.Text.StringBuilder)">
            <summary>
            Append the serialized form of this symbolic regex node to the stringbuilder
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.ToArray">
            <summary>
            Converts a concatenation into an array, 
            returns a non-concatenation in a singleton array.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.AppendToList(Microsoft.Automata.SymbolicRegexNode{`0},System.Collections.Generic.List{Microsoft.Automata.SymbolicRegexNode{`0}})">
            <summary>
            should only be used only if this is a concatenation node
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsDotStar">
            <summary>
            Returns true if this is equivalent to .*
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsNothing">
            <summary>
            Returns true if this is equivalent to [0-[0]]
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsStar">
            <summary>
            Returns true iff this is a loop whose lower bound is 0 and upper bound is max
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.HasUpperBound">
            <summary>
            Returns true iff this loop has an upper bound
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.HasLowerBound">
            <summary>
            Returns true iff this loop has a lower bound
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsMaybe">
            <summary>
            Returns true iff this is a loop whose lower bound is 0 and upper bound is 1
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsEpsilon">
            <summary>
            Returns true if this is Epsilon
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.Alts">
            <summary>
            Alternatives of an OR
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.Kind">
            <summary>
            Gets the kind of the regex
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.OrCount">
            <summary>
            Number of alternative branches if this is an or-node. 
            If this is not an or-node then the value is 1.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.Left">
            <summary>
            Left child of a binary node (the child of a unary node, the true-branch of an Ite-node)
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.Right">
            <summary>
            Right child of a binary node (the false-branch of an Ite-node)
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.LowerBound">
            <summary>
            The lower bound of a loop
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.UpperBound">
            <summary>
            The upper bound of a loop
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.Set">
            <summary>
            The set of a singleton
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegexNode`1._ConcatCount">
            <summary>
            Returns the number of top-level concatenation nodes.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IteCond">
            <summary>
            IfThenElse condition
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsPlus">
            <summary>
            Returns true iff this is a loop whose lower bound is 1 and upper bound is max
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsSartAnchor">
            <summary>
            Returns true iff this is a start-anchor
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsStartOfLineAnchor">
            <summary>
            Returns true iff this is an anchor for detecting start of line (including first line or start of input)
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsEndAnchor">
            <summary>
            Returns true iff this is an anchor for detecting end of input
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsEndOfLineAnchor">
            <summary>
            Returns true iff this is an anchor for detecting end of line (including last line or end of input)
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsAnchor">
            <summary>
            Returns true iff this is either a start-anchor or an end-anchor
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.#ctor(Microsoft.Automata.SymbolicRegexBuilder{`0},Microsoft.Automata.SymbolicRegexKind,Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.SymbolicRegexNode{`0},System.Int32,System.Int32,`0,Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.SymbolicRegexSet{`0})">
            <summary>
            AST node of a symbolic regex
            </summary>
            <param name="builder">the builder</param>
            <param name="kind">what kind of node</param>
            <param name="left">left child</param>
            <param name="right">right child</param>
            <param name="lower">lower bound of a loop</param>
            <param name="upper">upper boubd of a loop</param>
            <param name="set">singelton set</param>
            <param name="iteCond">if-then-else condition</param>
            <param name="alts">alternatives set of a disjunction</param>
            <param name="seq">sequence of singleton sets</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.MkConcat(Microsoft.Automata.SymbolicRegexBuilder{`0},Microsoft.Automata.SymbolicRegexNode{`0},Microsoft.Automata.SymbolicRegexNode{`0})">
            <summary>
            Only call MkConcat when left and right are flat, the resulting concat(left,right) is then also flat,
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.ToString">
            <summary>
            Produce a string representation of the symbolic regex. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.Restrict(`0)">
            <summary>
            Transform the symbolic regex so that all singletons have been intersected with the given predicate pred. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.GetFixedLength">
            <summary>
            Returns the fixed matching length of the regex or -1 if the regex does not have a fixed matching length.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.ReplaceAnchors(System.Boolean,System.Boolean)">
            <summary>
            Replace all anchors (^ and $) in the symbolic regex with () and missing anchors with .*
            </summary>
            <param name="isBeg">if true (default) then this is the beginning borderline and missing ^ is replaced with .*</param>
            <param name="isEnd">if true (default) then this is the end borderline and missing $ is replaced with .*</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.MkDerivative(`0)">
            <summary>
            Takes the derivative of the symbolic regex wrt elem. 
            Assumes that elem is either a minterm wrt the predicates of the whole regex or a singleton set.
            </summary>
            <param name="elem">given element wrt which the derivative is taken</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.GetConditinalDerivatives(`0)">
            <summary>
            Takes the Antimirov derivative of the symbolic regex wrt elem. 
            Assumes that elem is either a minterm wrt the predicates of the whole regex or a singleton set.
            </summary>
            <param name="elem">given element wrt which the derivative is taken</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.Explore(Microsoft.Automata.ICounter[]@,Microsoft.Automata.SymbolicRegexNode{`0}[]@,System.Collections.Generic.List{Microsoft.Automata.ICounter}@,System.Boolean,System.Int32)">
            <summary>
            Counter automaton exploration utility
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.Explore(System.Collections.Generic.Dictionary{System.Int32,Microsoft.Automata.ICounter}@,System.Collections.Generic.Dictionary{System.Int32,Microsoft.Automata.SymbolicRegexNode{`0}}@,System.Boolean)">
            <summary>
            Counter automaton exploration utility
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.CreateCountingAutomaton(System.Boolean)">
            <summary>
            Convert the regex to a counting automaton
            </summary>
            <param name="makeMonadic">if true then nonmonadic loops are removed</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.CreateCountingAutomatonPushIncr(System.Boolean)">
            <summary>
            Convert the regex to a counting automaton
            </summary>
            <param name="makeMonadic">if true then nonmonadic loops are removed</param>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsNullable">
            <summary>
            true iff epsilon is accepted
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.GetPredicates">
            <summary>
            Returns the set of all predicates that occur in the regex
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.CollectPredicates_helper(System.Collections.Generic.HashSet{`0})">
            <summary>
            Collects all predicates that occur in the regex into the given set predicates
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.ComputeMinterms">
            <summary>
            Compute all the minterms from the predicates in this regex.
            If S implements IComparable then sort the result in increasing order.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.Reverse">
            <summary>
            Create the reverse of this regex
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.Simplify(System.Boolean)">
            <summary>
            Unwind lower loop boundaries
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.DecrementBoundedLoopCount(System.Boolean)">
            <summary>
            Only valid to call if there is a single bounded loop
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.GetFixedPrefix(Microsoft.Automata.CharSetSolver,System.Boolean@)">
            <summary>
            Gets the string prefix that the regex must match or the empty string if such a prefix does not exist.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegexNode`1.isLazyLoop">
            <summary>
            true if this node is a lazy loop
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.GetStartSet(Microsoft.Automata.ICharAlgebra{`0})">
            <summary>
            Gets the predicate that covers all elements that make some progress. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.ShowGraph(System.Int32,System.String,System.Boolean,System.Boolean)">
            <summary>
            Unwind the regex and show the resulting state graph
            </summary>
            <param name="bound">roughly the maximum number of states</param>
            <param name="name">name for the graph, used also as .dgml file name</param>
            <param name="matchAnywhere">if true then pretend that there is a .* at the beginning</param>
            <param name="hideDerivatives">if true then hide derivatives in state labels</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.Unwind(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Unwind the regex into an automaton that can be displayed as a graph.
            </summary>
            <param name="bound">roughly the maximum number of states, 0 or negative value means no bound</param>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.ExistsNode(System.Predicate{Microsoft.Automata.SymbolicRegexNode{`0}})">
            <summary>
            Returns true iff there exists a node that satisfies the predicate
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsNonmonadicBoundedLoop">
            <summary>
            Returns true if this node represents a bounded loop whose body is nonmonadic.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsMonadicLoopWithLowerButWihtoutUpperBound">
            <summary>
            Returns true if this node is a monadic loop with lower bound but no upper bound.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.MkMonadic">
            <summary>
            Unwinds nonmonadic bounded quantifiers, and splits monadic bounded quantifiers without upper bounds to a fixed loop followed by Kleene star
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsBoundedLoop">
            <summary>
            Returns true if this is a loop with an upper bound
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexNode`1.IsSinglePass">
            <summary>
            Returns true if the match-end of this regex can be determined with a 
            single pass from the start. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.CheckIfContainsLazyLoop">
            <summary>
            Returns true if the regex contains a lazy loop
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.CheckIfAllLoopsAreLazy">
            <summary>
            Returns true if there are no loops or if all loops are lazy. 
            </summary>
        </member>
        <member name="M:Microsoft.Automata.SymbolicRegexNode`1.CheckIfLoopExists">
            <summary>
            Returns true if there is a loop
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegexSetKind">
            <summary>
            The kind of a symbolic regex set
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegexSet`1">
            <summary>
            Represents a set of symbolic regexes that is either a disjunction or a conjunction
            </summary>
        </member>
        <member name="F:Microsoft.Automata.SymbolicRegexSet`1.watchdog">
            <summary>
            if >= 0 then the maximal length of a watchdog in the set
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexSet`1.IsEverything">
            <summary>
            Denotes the empty conjunction
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexSet`1.IsNothing">
            <summary>
            Denotes the empty disjunction
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexSet`1.Count">
            <summary>
            How many elements are there in this set
            </summary>
        </member>
        <member name="P:Microsoft.Automata.SymbolicRegexSet`1.IsSigleton">
            <summary>
            True iff the set is a singleton
            </summary>
        </member>
        <member name="T:Microsoft.Automata.SymbolicRegexSet`1.Enumerator">
            <summary>
            Enumerates all symbolic regexes in the set
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomataTextTemplate">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplate.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomataTextTemplateBase">
            <summary>
            Base class for this transformation
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomataTextTemplateBase.GenerationEnvironment">
            <summary>
            The string builder that generation-time code is using to assemble generated output
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomataTextTemplateBase.Errors">
            <summary>
            The error collection for the generation process
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomataTextTemplateBase.indentLengths">
            <summary>
            A list of the lengths of each indent that was added with PushIndent
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomataTextTemplateBase.CurrentIndent">
            <summary>
            Gets the current indent we use when adding lines to the output
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomataTextTemplateBase.Session">
            <summary>
            Current transformation session
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.Write(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.WriteLine(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.Write(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.WriteLine(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.Error(System.String)">
            <summary>
            Raise an error
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.Warning(System.String)">
            <summary>
            Raise a warning
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.PushIndent(System.String)">
            <summary>
            Increase the indent
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.PopIndent">
            <summary>
            Remove the last indent that was added with PushIndent
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.ClearIndent">
            <summary>
            Remove any indentation
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomataTextTemplateBase.ToStringInstanceHelper">
            <summary>
            Utility class to produce culture-oriented representation of an object as a string.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomataTextTemplateBase.ToStringInstanceHelper.FormatProvider">
            <summary>
            Gets or sets format provider to be used by ToStringWithCulture method.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomataTextTemplateBase.ToStringInstanceHelper.ToStringWithCulture(System.Object)">
            <summary>
            This is called from the compile/run appdomain to convert objects within an expression block to a string
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomataTextTemplateBase.ToStringHelper">
            <summary>
            Helper to produce culture-oriented representation of an object as a string
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomatonMovesTextTemplate">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplate.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase">
            <summary>
            Base class for this transformation
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.GenerationEnvironment">
            <summary>
            The string builder that generation-time code is using to assemble generated output
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.Errors">
            <summary>
            The error collection for the generation process
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.indentLengths">
            <summary>
            A list of the lengths of each indent that was added with PushIndent
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.CurrentIndent">
            <summary>
            Gets the current indent we use when adding lines to the output
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.Session">
            <summary>
            Current transformation session
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.Write(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.WriteLine(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.Write(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.WriteLine(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.Error(System.String)">
            <summary>
            Raise an error
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.Warning(System.String)">
            <summary>
            Raise a warning
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.PushIndent(System.String)">
            <summary>
            Increase the indent
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.PopIndent">
            <summary>
            Remove the last indent that was added with PushIndent
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.ClearIndent">
            <summary>
            Remove any indentation
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.ToStringInstanceHelper">
            <summary>
            Utility class to produce culture-oriented representation of an object as a string.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.ToStringInstanceHelper.FormatProvider">
            <summary>
            Gets or sets format provider to be used by ToStringWithCulture method.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.ToStringInstanceHelper.ToStringWithCulture(System.Object)">
            <summary>
            This is called from the compile/run appdomain to convert objects within an expression block to a string
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonMovesTextTemplateBase.ToStringHelper">
            <summary>
            Helper to produce culture-oriented representation of an object as a string
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomatonTextTemplate">
            <summary>
            Class to produce the template output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplate.TransformText">
            <summary>
            Create the template output
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomatonTextTemplateBase">
            <summary>
            Base class for this transformation
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonTextTemplateBase.GenerationEnvironment">
            <summary>
            The string builder that generation-time code is using to assemble generated output
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonTextTemplateBase.Errors">
            <summary>
            The error collection for the generation process
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonTextTemplateBase.indentLengths">
            <summary>
            A list of the lengths of each indent that was added with PushIndent
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonTextTemplateBase.CurrentIndent">
            <summary>
            Gets the current indent we use when adding lines to the output
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonTextTemplateBase.Session">
            <summary>
            Current transformation session
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.Write(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.WriteLine(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.Write(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.WriteLine(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.Error(System.String)">
            <summary>
            Raise an error
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.Warning(System.String)">
            <summary>
            Raise a warning
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.PushIndent(System.String)">
            <summary>
            Increase the indent
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.PopIndent">
            <summary>
            Remove the last indent that was added with PushIndent
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.ClearIndent">
            <summary>
            Remove any indentation
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Templates.AutomatonTextTemplateBase.ToStringInstanceHelper">
            <summary>
            Utility class to produce culture-oriented representation of an object as a string.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonTextTemplateBase.ToStringInstanceHelper.FormatProvider">
            <summary>
            Gets or sets format provider to be used by ToStringWithCulture method.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Templates.AutomatonTextTemplateBase.ToStringInstanceHelper.ToStringWithCulture(System.Object)">
            <summary>
            This is called from the compile/run appdomain to convert objects within an expression block to a string
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Templates.AutomatonTextTemplateBase.ToStringHelper">
            <summary>
            Helper to produce culture-oriented representation of an object as a string
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Utilities.ArgumentType">
            <summary>
            Used to control parsing of command line arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Utilities.ArgumentType.Required">
            <summary>
            Indicates that this field is required. An error will be displayed
            if it is not present when parsing arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Utilities.ArgumentType.Unique">
            <summary>
            Only valid in conjunction with Multiple.
            Duplicate values will result in an error.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Utilities.ArgumentType.Multiple">
            <summary>
            Inidicates that the argument may be specified more than once.
            Only valid if the argument is a collection
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Utilities.ArgumentType.AtMostOnce">
            <summary>
            The default type for non-collection arguments.
            The argument is not required, but an error will be reported if it is specified more than once.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Utilities.ArgumentType.LastOccurenceWins">
            <summary>
            For non-collection arguments, when the argument is specified more than
            once no error is reported and the value of the argument is the last
            value which occurs in the argument list.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Utilities.ArgumentType.MultipleUnique">
            <summary>
            The default type for collection arguments.
            The argument is permitted to occur multiple times, but duplicate 
            values will cause an error to be reported.
            </summary>
        </member>
        <member name="F:Microsoft.Automata.Utilities.ArgumentType.AtLeastOnce">
            <summary>
            The default type for non-collection arguments.
            The argument is not required, but an error will be reported if it is specified more than once.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Utilities.ArgumentAttribute">
            <summary>
            Allows control of command line parsing.
            Attach this attribute to instance fields of types used
            as the destination of command line argument parsing.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Utilities.ArgumentAttribute.#ctor(Microsoft.Automata.Utilities.ArgumentType)">
            <summary>
            Allows control of command line parsing.
            </summary>
            <param name="type"> Specifies the error checking to be done on the argument. </param>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.Type">
            <summary>
            The error checking to be done on the argument.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.DefaultShortName">
            <summary>
            Returns true if the argument did not have an explicit short name specified.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.ShortName">
            <summary>
            The short name of the argument.
            Set to null means use the default short name if it does not
            conflict with any other parameter name.
            Set to String.Empty for no short name.
            This property should not be set for DefaultArgumentAttributes.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.DefaultLongName">
            <summary>
            Returns true if the argument did not have an explicit long name specified.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.LongName">
            <summary>
            The long name of the argument.
            Set to null means use the default long name.
            The long name for every argument must be unique.
            It is an error to specify a long name of String.Empty.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.DefaultValue">
            <summary>
            The default value of the argument.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.HasDefaultValue">
            <summary>
            Returns true if the argument has a default value.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.HasHelpText">
            <summary>
            Returns true if the argument has help text specified.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.ArgumentAttribute.HelpText">
            <summary>
            The help text for the argument.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Utilities.DefaultArgumentAttribute">
            <summary>
            Indicates that this argument is the default argument.
            '/' or '-' prefix only the argument value is specified.
            The ShortName property should not be set for DefaultArgumentAttribute
            instances. The LongName property is used for usage text only and
            does not affect the usage of the argument.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Utilities.DefaultArgumentAttribute.#ctor(Microsoft.Automata.Utilities.ArgumentType)">
            <summary>
            Indicates that this argument is the default argument.
            </summary>
            <param name="type"> Specifies the error checking to be done on the argument. </param>
        </member>
        <member name="T:Microsoft.Automata.Utilities.ErrorReporter">
            <summary>
            A delegate used in error reporting.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Utilities.CommandLineParser">
             <summary>
             Parser for command line arguments.
            
             The parser specification is infered from the instance fields of the object
             specified as the destination of the parse.
             Valid argument types are: int, uint, string, bool, enums
             Also argument types of Array of the above types are also valid.
             
             Error checking options can be controlled by adding a ArgumentAttribute
             to the instance fields of the destination object.
            
             At most one field may be marked with the DefaultArgumentAttribute
             indicating that arguments without a '-' or '/' prefix will be parsed as that argument.
            
             If not specified then the parser will infer default options for parsing each
             instance field. The default long name of the argument is the field name. The
             default short name is the first character of the long name. Long names and explicitly
             specified short names must be unique. Default short names will be used provided that
             the default short name does not conflict with a long name or an explicitly
             specified short name.
            
             Arguments which are array types are collection arguments. Collection
             arguments can be specified multiple times.
             </summary>
        </member>
        <member name="F:Microsoft.Automata.Utilities.CommandLineParser.NewLine">
            <summary>
            The System Defined new line string.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ParseArgumentsWithUsage(System.String[],System.Object)">
            <summary>
            Parses Command Line Arguments. Displays usage message to Console.Out
            if /?, /help or invalid arguments are encounterd.
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ParseArgumentsWithUsage(System.String[],System.Type)">
            <summary>
            Parses Command Line Arguments. Displays usage message to Console.Out
            if /?, /help or invalid arguments are encounterd.
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ParseArguments(System.String[],System.Object)">
            <summary>
            Parses Command Line Arguments. 
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ParseArguments(System.String[],System.Type)">
            <summary>
            Parses Command Line Arguments. 
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ParseArguments(System.String[],System.Object,Microsoft.Automata.Utilities.ErrorReporter)">
            <summary>
            Parses Command Line Arguments. 
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <param name="reporter"> The destination for parse errors. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ParseArguments(System.String[],System.Type,Microsoft.Automata.Utilities.ErrorReporter)">
            <summary>
            Parses Command Line Arguments. 
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <param name="reporter"> The destination for parse errors. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ParseHelp(System.String[])">
            <summary>
            Checks if a set of arguments asks for help.
            </summary>
            <param name="args"> Args to check for help. </param>
            <returns> Returns true if args contains /? or /help. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ArgumentsUsage(System.Type)">
            <summary>
            Returns a Usage string for command line argument parsing.
            Use ArgumentAttributes to control parsing behaviour.
            Formats the output to the width of the current console window.
            </summary>
            <param name="argumentType"> The type of the arguments to display usage for. </param>
            <returns> Printable string containing a user friendly description of command line arguments. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ArgumentsUsage(System.Type,System.Int32)">
            <summary>
            Returns a Usage string for command line argument parsing.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="argumentType"> The type of the arguments to display usage for. </param>
            <param name="columns"> The number of columns to format the output to. </param>
            <returns> Printable string containing a user friendly description of command line arguments. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.IndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>
            Searches a StringBuilder for a character
            </summary>
            <param name="text"> The text to search. </param>
            <param name="value"> The character value to search for. </param>
            <param name="startIndex"> The index to stat searching at. </param>
            <returns> The index of the first occurence of value or -1 if it is not found. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.LastIndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>
            Searches a StringBuilder for a character in reverse
            </summary>
            <param name="text"> The text to search. </param>
            <param name="value"> The character to search for. </param>
            <param name="startIndex"> The index to start the search at. </param>
            <returns>The index of the last occurence of value in text or -1 if it is not found. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.#ctor(System.Type,Microsoft.Automata.Utilities.ErrorReporter)">
            <summary>
            Creates a new command line argument parser.
            </summary>
            <param name="argumentSpecification"> The type of object to  parse. </param>
            <param name="reporter"> The destination for parse errors. </param>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.ParseArgumentList(System.String[],System.Object)">
            <summary>
            Parses an argument list into an object
            </summary>
            <param name="args"></param>
            <param name="destination"></param>
            <returns> true if an error occurred </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.Parse(System.String[],System.Object)">
            <summary>
            Parses an argument list.
            </summary>
            <param name="args"> The arguments to parse. </param>
            <param name="destination"> The destination of the parsed arguments. </param>
            <returns> true if no parse errors were encountered. </returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.CommandLineParser.GetUsageString(System.Int32)">
            <summary>
            A user firendly usage string describing the command line argument syntax.
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.CommandLineParser.HasDefaultArgument">
            <summary>
            Does this parser have a default argument.
            </summary>
            <value> Does this parser have a default argument. </value>
        </member>
        <member name="T:Microsoft.Automata.Utilities.CppCodeGenerator">
            <summary>
            Provides functionality for generating c++ acceptors for given automata or regexes
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Utilities.HighTimer">
            <summary>
            High precision timer
            </summary>
        </member>
        <member name="P:Microsoft.Automata.Utilities.HighTimer.Frequency">
            <summary>
            Gets the frequency.
            </summary>
            <value>The frequency.</value>
        </member>
        <member name="P:Microsoft.Automata.Utilities.HighTimer.Now">
            <summary>
            Gets the current ticks value.
            </summary>
            <value>The now.</value>
        </member>
        <member name="M:Microsoft.Automata.Utilities.HighTimer.ToSeconds(System.Int64,System.Int64)">
            <summary>
            Returns the duration of the timer (in seconds)
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.HighTimer.ToSeconds(System.Int64)">
             <summary>
            Returns the duration in seconds
             </summary>
             <param name="ticks">The ticks.</param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.HighTimer.ToSecondsFromNow(System.Int64)">
             <summary>
            Returns the duration in seconds from <paramref name="start"/>
             </summary>
             <param name="start">The start.</param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.IgnoreCaseTransformer.Apply(Microsoft.Automata.BDD)">
            <summary>
            For all letters in the bdd add their lower and upper case equivalents.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Utilities.RegexToRangeAutomatonSerializer">
            <summary>
            Functionality to serialize a regex as a range automaton and to deserialize as Automaton over BDDs.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Utilities.RegexToRangeAutomatonSerializer.ReadFromRanges(Microsoft.Automata.CharSetSolver,System.Int32,System.Int32[],System.Collections.Generic.IEnumerable{System.Int32[]})">
            <summary>
            Each transition has the form int[]{fromState, intervalStart, intervalEnd, toState}.
            If intervalStart = intervalEnd = -1 then this is an epsilon move.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Utilities.UnicodeCategoryRangesGenerator">
            <summary>
            Utility for generating unicode category ranges and corresponing binary decision diagrams
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Utilities.UnicodeCategoryRangesGenerator.Generate(System.String,System.String,System.String)">
            <summary>
            Create a file classname.cs in the directory path.
            The file contains the static class with name classname and has namespace namespacename.
            The class has static fields that map unicode categories to their character ranges
            and provide whitespace ranges.
            The fields are for the ASCII case (7 bits), CP437 case (8 bits) and for UTF16 (16 bits).
            Overwrites an existing file, even if the existing file is write protected.
            </summary>
            <param name="namespacename">namespace for the class</param>
            <param name="classname">name of the class</param>
            <param name="path">path where the file is written</param>
        </member>
        <member name="T:Microsoft.Automata.Utilities.Ranges">
            <summary>
            Used internally for creating a collection of ranges for serialization.
            </summary>
        </member>
        <member name="T:Microsoft.Automata.Utilities.UTF8Encoding">
            <summary>
            Methods for decoding UTF8 encoded strings.
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Utilities.UTF8Encoding.UTF8toUTF16(System.Byte[],System.Int32@,System.UInt16@,System.UInt16@)">
            <summary>
            Incremental UTF8 to UTF16 decoder. Outputs the next UTF-16 character and advances the current input position.
            Returns true if the decoding succeeds, returns false otherwise.
            </summary>
            <param name="input">UFT8 encoded input</param>
            <param name="i">current position in the input</param>
            <param name="partial_low_surrogate">low surrogate leftover from previous high surrogate decoding</param>
            <param name="c">decoded UTF16 character code or surrogate (0 if return value is false)</param>
            <returns>true iff the decoding succeeds</returns>
        </member>
        <member name="M:Microsoft.Automata.Utilities.UTF8Encoding.UTF8toUTF16_backwards(System.Byte[],System.Int32@,System.UInt16@,System.UInt16@)">
            <summary>
            Assuming correctly encoded input.
            Called only if input[i] is non-ASCII
            </summary>
        </member>
        <member name="M:Microsoft.Automata.Utilities.UTF8Encoding.DecodeNextNonASCII(System.Byte[],System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Decode the next codepoint in the input.
            Here input[i] is assumed to be non-ASCII.
            The input byte array is asssumed to be valid UTF8 encoded Unicode text.
            </summary>
            <param name="input">UTF8 encoded Unicode text</param>
            <param name="i">position of the current start byte</param>
            <param name="step">how many bytes were consumed</param>
            <param name="codepoint">computed Unicode codepoint</param>
            <returns></returns>
        </member>
        <member name="T:QUT.Gppg.LexLocationInFile">
            <summary>
            Lexical location extended with optional file name info.
            </summary>
        </member>
        <member name="M:QUT.Gppg.LexLocationInFile.#ctor">
            <summary>
            Default no-arg constructor.
            </summary>
        </member>
        <member name="P:QUT.Gppg.LexLocationInFile.File">
            <summary>
            Source file of the location
            </summary>
        </member>
        <member name="T:QUT.Gppg.ShiftReduceParser`2">
            <summary>
            Abstract class for GPPG shift-reduce parsers.
            Parsers generated by GPPG derive from this base
            class, overriding the abstract Initialize() and
            DoAction() methods.
            </summary>
            <typeparam name="TValue">Semantic value type</typeparam>
            <typeparam name="TSpan">Location type</typeparam>
        </member>
        <member name="P:QUT.Gppg.ShiftReduceParser`2.Scanner">
            <summary>
            The abstract scanner for this parser.
            </summary>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.#ctor(QUT.Gppg.AbstractScanner{`0,`1})">
            <summary>
            Constructor for base class
            </summary>
            <param name="scanner">Scanner instance for this parser</param>
        </member>
        <member name="F:QUT.Gppg.ShiftReduceParser`2.CurrentSemanticValue">
            <summary>
            The current value of the "$$" symbolic variable in the parser
            </summary>
        </member>
        <member name="F:QUT.Gppg.ShiftReduceParser`2.CurrentLocationSpan">
            <summary>
            The current value of the "@$" symbolic variable in the parser
            </summary>
        </member>
        <member name="P:QUT.Gppg.ShiftReduceParser`2.ValueStack">
            <summary>
            The stack of semantic value (YYSTYPE) values.
            </summary>
        </member>
        <member name="P:QUT.Gppg.ShiftReduceParser`2.LocationStack">
            <summary>
            The stack of location value (YYLTYPE) varlues.
            </summary>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.InitRules(QUT.Gppg.Rule[])">
            <summary>
            Initialization method to allow derived classes
            to insert the rule list into this base class.
            </summary>
            <param name="rules">The array of Rule objects</param>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.InitStates(QUT.Gppg.State[])">
            <summary>
            Initialization method to allow derived classes to
            insert the states table into this base class.
            </summary>
            <param name="states">The pre-initialized states table</param>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.InitStateTable(System.Int32)">
            <summary>
            OBSOLETE FOR VERSION 1.4.0
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.InitSpecialTokens(System.Int32,System.Int32)">
            <summary>
            Initialization method to allow derived classes
            to insert the special value for the error and EOF tokens.
            </summary>
            <param name="err">The error state ordinal</param>
            <param name="end">The EOF stat ordinal</param>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.InitNonTerminals(System.String[])">
            <summary>
            Initialization method to allow derived classes to
            insert the non-terminal symbol names into this base class.
            </summary>
            <param name="names">Non-terminal symbol names</param>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.YYAccept">
            <summary>
            Force parser to terminate, returning "true"
            </summary>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.YYAbort">
            <summary>
            Force parser to terminate, returning "false"
            </summary>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.YYError">
            <summary>
            Force parser to terminate, returning
            "false" if error recovery fails.
            </summary>
        </member>
        <member name="P:QUT.Gppg.ShiftReduceParser`2.YYRecovering">
            <summary>
            Check if parser in error recovery state.
            </summary>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.Initialize">
            <summary>
            Abstract base method. ShiftReduceParser calls this
            to initialize the base class data structures.  Concrete
            parser classes must override this method.
            </summary>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.Parse">
            <summary>
            Main entry point of the Shift-Reduce Parser.
            </summary>
            <returns>True if parse succeeds, else false for
            unrecoverable errors</returns>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.DoAction(System.Int32)">
            <summary>
            Execute the selected action from array.
            Must be overriden in derived classes.
            </summary>
            <param name="actionNumber">Index of the action to perform</param>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.yyclearin">
            <summary>
            Traditional YACC method.  Discards the next input token.
            </summary>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.yyerrok">
            <summary>
            Tradional YACC method. Clear the "recovering" flag.
            </summary>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.AddState(System.Int32,QUT.Gppg.State)">
            <summary>
            OBSOLETE FOR VERSION 1.4.0
            Method used by derived types to insert new
            state instances in the "states" array.
            </summary>
            <param name="stateNumber">index of the state</param>
            <param name="state">data for the state</param>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.TerminalToString(System.Int32)">
            <summary>
            Abstract state class naming terminal symbols.
            This is overridden by derived classes with the
            name (or alias) to be used in error messages.
            </summary>
            <param name="terminal">The terminal ordinal</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Gppg.ShiftReduceParser`2.CharToString(System.Char)">
            <summary>
            Return text representation of argument character
            </summary>
            <param name="input">The character to convert</param>
            <returns>String representation of the character</returns>
        </member>
        <member name="T:QUT.Gppg.IMerge`1">
            <summary>
            Classes implementing this interface must supply a
            method that merges two location objects to return
            a new object of the same type.
            GPPG-generated parsers have the default location
            action equivalent to "@$ = @1.Merge(@N);" where N
            is the right-hand-side length of the production.
            </summary>
            <typeparam name="TSpan">The Location type</typeparam>
        </member>
        <member name="M:QUT.Gppg.IMerge`1.Merge(`0)">
            <summary>
            Interface method that creates a location object from
            the current and last object.  Typically used to create
            a location object extending from the start of the @1
            object to the end of the @N object.
            </summary>
            <param name="last">The lexically last object to merge</param>
            <returns>The merged location object</returns>
        </member>
        <member name="T:QUT.Gppg.LexLocation">
            <summary>
            This is the default class that carries location
            information from the scanner to the parser.
            If you don't declare "%YYLTYPE Foo" the parser
            will expect to deal with this type.
            </summary>
        </member>
        <member name="P:QUT.Gppg.LexLocation.StartLine">
            <summary>
            The line at which the text span starts.
            </summary>
        </member>
        <member name="P:QUT.Gppg.LexLocation.StartColumn">
            <summary>
            The column at which the text span starts.
            </summary>
        </member>
        <member name="P:QUT.Gppg.LexLocation.EndLine">
            <summary>
            The line on which the text span ends.
            </summary>
        </member>
        <member name="P:QUT.Gppg.LexLocation.EndColumn">
            <summary>
            The column of the first character
            beyond the end of the text span.
            </summary>
        </member>
        <member name="M:QUT.Gppg.LexLocation.#ctor">
            <summary>
            Default no-arg constructor.
            </summary>
        </member>
        <member name="M:QUT.Gppg.LexLocation.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor for text-span with given start and end.
            </summary>
            <param name="sl">start line</param>
            <param name="sc">start column</param>
            <param name="el">end line </param>
            <param name="ec">end column</param>
        </member>
        <member name="M:QUT.Gppg.LexLocation.Merge(QUT.Gppg.LexLocation)">
            <summary>
            Create a text location which spans from the 
            start of "this" to the end of the argument "last"
            </summary>
            <param name="last">The last location in the result span</param>
            <returns>The merged span</returns>
        </member>
        <member name="T:QUT.Gppg.AbstractScanner`2">
            <summary>
            Abstract scanner class that GPPG expects its scanners to 
            extend.
            </summary>
            <typeparam name="TValue">Semantic value type YYSTYPE</typeparam>
            <typeparam name="TSpan">Source location type YYLTYPE</typeparam>
        </member>
        <member name="F:QUT.Gppg.AbstractScanner`2.yylval">
            <summary>
            Lexical value optionally set by the scanner. The value
            is of the %YYSTYPE type declared in the parser spec.
            </summary>
        </member>
        <member name="P:QUT.Gppg.AbstractScanner`2.yylloc">
            <summary>
            Current scanner location property. The value is of the
            type declared by %YYLTYPE in the parser specification.
            </summary>
        </member>
        <member name="M:QUT.Gppg.AbstractScanner`2.yylex">
            <summary>
            Main call point for LEX-like scanners.  Returns an int
            corresponding to the token recognized by the scanner.
            </summary>
            <returns>An int corresponding to the token</returns>
        </member>
        <member name="M:QUT.Gppg.AbstractScanner`2.yyerror(System.String,System.Object[])">
            <summary>
            Traditional error reporting provided by LEX-like scanners
            to their YACC-like clients.
            </summary>
            <param name="format">Message format string</param>
            <param name="args">Optional array of args</param>
        </member>
        <member name="T:QUT.Gppg.State">
            <summary>
            Encapsulated state for the parser.
            Opaque to users, visible to the tool-generated code.
            </summary>
        </member>
        <member name="F:QUT.Gppg.State.number">
            <summary>
            The number of states in the automaton.
            </summary>
        </member>
        <member name="M:QUT.Gppg.State.#ctor(System.Int32[],System.Int32[])">
            <summary>
            State transition data for this state. Pairs of elements of the 
            goto array associate symbol ordinals with next state indices.
            The actions array is passed to another constructor. 
            </summary>
            <param name="actions">The action list</param>c
            <param name="goToList">Next state data</param>
        </member>
        <member name="M:QUT.Gppg.State.#ctor(System.Int32[])">
            <summary>
            Action data for this state. Pairs of elements of the 
            action array associate action ordinals with each of
            those symbols that have actions in the current state.
            </summary>
            <param name="actions">The action array</param>
        </member>
        <member name="M:QUT.Gppg.State.#ctor(System.Int32)">
            <summary>
            Set the default action for this state.
            </summary>
            <param name="defaultAction">Ordinal of the default action</param>
        </member>
        <member name="M:QUT.Gppg.State.#ctor(System.Int32,System.Int32[])">
            <summary>
            Set the default action and the state transition table.
            </summary>
            <param name="defaultAction">The default action</param>
            <param name="goToList">Transitions from this state</param>
        </member>
        <member name="T:QUT.Gppg.Rule">
            <summary>
            Rule representation at runtime.
            </summary>
        </member>
        <member name="M:QUT.Gppg.Rule.#ctor(System.Int32,System.Int32[])">
            <summary>
            Rule constructor.  This holds the ordinal of
            the left hand side symbol, and the list of
            right hand side symbols, in lexical order.
            </summary>
            <param name="left">The LHS non-terminal</param>
            <param name="right">The RHS symbols, in lexical order</param>
        </member>
        <member name="T:QUT.Gppg.PushdownPrefixState`1">
            <summary>
            Stack utility for the shift-reduce parser.
            GPPG parsers have three instances:
            (1) The parser state stack, T = QUT.Gppg.State,
            (2) The semantic value stack, T = TValue,
            (3) The location stack, T = TSpan.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:QUT.Gppg.PushdownPrefixState`1.Item(System.Int32)">
            <summary>
            Indexer for values of the stack below the top.
            </summary>
            <param name="index">index of the element, starting from the bottom</param>
            <returns>the selected element</returns>
        </member>
        <member name="P:QUT.Gppg.PushdownPrefixState`1.Depth">
            <summary>
            The current depth of the stack.
            </summary>
        </member>
    </members>
</doc>
